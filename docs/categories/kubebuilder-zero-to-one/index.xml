<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kubebuilder-zero-to-one on 一壶酒一溪云</title><link>https://typonotes.com/categories/kubebuilder-zero-to-one/</link><description>Recent content in kubebuilder-zero-to-one on 一壶酒一溪云</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 09 Jan 2023 01:28:03 +0800</lastBuildDate><atom:link href="https://typonotes.com/categories/kubebuilder-zero-to-one/index.xml" rel="self" type="application/rss+xml"/><item><title>《kubebuilder 从零开始实战》 - 01. 使用 kuberbuilder 初始化项目</title><link>https://typonotes.com/posts/books/kubebuilder-zero-to-one/01-kubebuilder-init-project/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/kubebuilder-zero-to-one/01-kubebuilder-init-project/</guid><description>使用 kuberbuilder 初始化项目 代码在: https://github.com/tangx/kubebuilder-zero-to-one 1 2 kubebuilder init --domain tangx.in kubebuilder create api --group myapp --version v1 --kind Redis 1 2 3 4 5 6 7 8 9 apiVersion: myapp.tangx.in/v1 kind: Redis metadata: name: my-op-redis spec: replicas: 1 port: 3333 1 2 3 4 5 # 安装 make install # 卸载 make uninstall 查看 crd 1 2 3 k get crd |grep tangx.in redis.myapp.tangx.in 2021-11-19T06:16:43Z</description></item><item><title>《kubebuilder 从零开始实战》 - 02. 定义对象 CRD 字段， 实现第一个 DEMO</title><link>https://typonotes.com/posts/books/kubebuilder-zero-to-one/02-simplest-redis-crd/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/kubebuilder-zero-to-one/02-simplest-redis-crd/</guid><description>定义对象 CRD 字段， 实现第一个 DEMO 代码在: https://github.com/tangx/kubebuilder-zero-to-one 定义 CRD Redis 对象字段 在 /api/v1/redis_types.go 中， 增加 Replicas 和 Port 字段。 1 2 3 4 5 6 7 8 9 type RedisSpec struct { // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster // Important: Run &amp;#34;make&amp;#34; to regenerate code after modifying this file // Foo is an example field of Redis. Edit redis_types.go to remove/update // Foo string `json:&amp;#34;foo,omitempty&amp;#34;` Replicas int `json:&amp;#34;replicas,omitempty&amp;#34;` Port int32 `json:&amp;#34;port,omitempty&amp;#34;` } 这个 RedisSpec 对应 /deploy/my-op-redis.yml 中的 spec 1 2 3 4 5 6 7 8 9 10 apiVersion: myapp.tangx.in/v1 kind: Redis metadata: name: my-op-redis spec: replicas: 1 port: 3333 编码 Reconcile 调谐逻辑 在 /controllers/redis_controller.go 中编码 R</description></item><item><title>《kubebuilder 从零开始实战》 - 03. 优化配置 发布 crd controller 到集群</title><link>https://typonotes.com/posts/books/kubebuilder-zero-to-one/03-deploy-crd-controller/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/kubebuilder-zero-to-one/03-deploy-crd-controller/</guid><description>优化配置 发布 crd controller 到集群 设置 docker server 网络代理， 避免编译的时候下载所依赖的 gcr.io 镜像失败。 参考文章 设置 docker server 网路代理 修改 Makefile, 设置默认 image name 1 2 3 4 VERSION ?= v$(shell cat .version) # Image URL to use all building/pushing image targets IMG ?= cr.docker.tangx.in/jtredis/controller:$(VERSION) 修改镜像 pull 策略。 在 /config/manager/manager.yaml 配置文件中， 添加 imagePullPolicy 策略。 由于本地开发， 并不准备上传到云上， 所以设置为 IfNotPresent。 1 2</description></item><item><title>《kubebuilder 从零开始实战》 - 04. 使用注解完整字段值约束</title><link>https://typonotes.com/posts/books/kubebuilder-zero-to-one/04-filed-validation-by-comment/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/kubebuilder-zero-to-one/04-filed-validation-by-comment/</guid><description>使用注解完整字段值约束 代码在: https://github.com/tangx/kubebuilder-zero-to-one 在 /api/v1/redis_types.go 中，使用注解完成字段值约束。 约束条件必须以 //+kubebuilder:validation:&amp;lt;METHOD&amp;gt;:=&amp;lt;VALUE&amp;gt; 为格式， 符号之间 没有空格。 约束条件必须 紧邻 字段， 且在字段上方。 https://book.kubebuilder.io/reference/markers/crd-validation.html 1 2 3 4 5 6 7 8 9 10 type RedisSpec struct { // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster // Important: Run &amp;#34;make&amp;#34; to regenerate code after modifying this file Replicas int `json:&amp;#34;replicas,omitempty&amp;#34;` //+kubebuilder:validation:Minimum:=1234 //+kubebuilder:validation:Maximum:=54321 Port int32 `json:&amp;#34;port,omitempty&amp;#34;` } 重新编译安装 1 make install 使用命令查看查看 1 2 3 4 5 6 7</description></item><item><title>《kubebuilder 从零开始实战》 - 05. 使用注解完整字段值约束</title><link>https://typonotes.com/posts/books/kubebuilder-zero-to-one/05-filed-validation-by-webhook/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/kubebuilder-zero-to-one/05-filed-validation-by-webhook/</guid><description>通过 webhook 进行字段验证 代码在: https://github.com/tangx/kubebuilder-zero-to-one 通过 kubebuilder 生成代码 1 2 3 4 5 # 创建 api kubebuilder create api --group myapp --version v1 --kind Redis # 创建 api 的 webhook kubebuilder create webhook --group myapp --version v1 --kind Redis --defaulting --programmatic-validation 增加 webhook 条件 在 /api/v1/redis_webhook.go 中增加检查条件。 检查 webhook 被触发有三个条件 Create / Update / Delete 时间节点, 分别对应三个方法。 如下是 创建时检查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func (r *Redis) ValidateCreate() error { redislog.Info(&amp;#34;validate create&amp;#34;, &amp;#34;name&amp;#34;, r.Name) // 条件判断 if</description></item><item><title>《kubebuilder 从零开始实战》 - 06. 使用 Operator 创建并发布一个 Pod</title><link>https://typonotes.com/posts/books/kubebuilder-zero-to-one/06-create-pod-by-redis-operator/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/kubebuilder-zero-to-one/06-create-pod-by-redis-operator/</guid><description>使用 Operator 创建并发布一个 Pod 代码在: https://github.com/tangx/kubebuilder-zero-to-one 1. 组装 k8s api 创建 pod 创建 /controllers/helper 目录， 这里面的代码实现 k8s Workloads 的创建。 具体实现就是封装 k8s workloads 的 api 对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // CreateRedis 创建 redis pod func CreateRedisPod2(ctx context.Context, client client.Client, config *appv1.Redis) error { pod := &amp;amp;corev1.Pod{} pod.Name = config.Name pod.Namespace = config.Namespace pod.Spec.Containers = []corev1.Container{ { Name: config.Name, Image: config.Spec.Image, ImagePullPolicy: corev1.PullIfNotPresent, Ports: []corev1.ContainerPort{ { ContainerPort: config.Spec.Port, }, }, }, } // ctx := context.Background() return client.Create(ctx, pod) } 补充说明一下，为什么要</description></item><item><title>《kubebuilder 从零开始实战》 - 07.1. 使用 OwnerReference 管理资源父子关系</title><link>https://typonotes.com/posts/books/kubebuilder-zero-to-one/07-1-delete-pod-by-redis-OwnerReference/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/kubebuilder-zero-to-one/07-1-delete-pod-by-redis-OwnerReference/</guid><description>使用 OwnerReference 管理资源父子关系 代码在: https://github.com/tangx/kubebuilder-zero-to-one https://kubernetes.io/blog/2021/05/14/using-finalizers-to-control-deletion/ 在上一章的代码可以通过如下命令创建一个 redis 实例， 并随即创建一个 Pod 1 ka -f deploy/ 但是在使用如下命令删除 redis 实例时， 虽然命令行界面提示删除成功， 但是创建的 Pod 依旧存在。 1 krm -f deploy/ 其原因是 redis 实例 与 Pod 之间 没有 建立关联关系。 那要如何创建关联关系呢？ 可以参考阅读官方博客，</description></item><item><title>《kubebuilder 从零开始实战》 - 07.2. 使用 finalizers 防止资源被删除</title><link>https://typonotes.com/posts/books/kubebuilder-zero-to-one/07-2-delete-pod-by-finalizers/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/kubebuilder-zero-to-one/07-2-delete-pod-by-finalizers/</guid><description>使用 finalizers 防止资源被删除 代码在: https://github.com/tangx/kubebuilder-zero-to-one 上一章使用了 OwnerReference 关联 redis instance 和所创建的 Pod， 这里的删除是通过 k8s 内置的关系处理器处理的。 https://kubernetes.io/blog/2021/05/14/using-finalizers-to-control-deletion/ 根据官方博客文档中的阐述， 当一个资源的额 finalizers 没有被清空时， 这个资源将无法被删除。 因此， 本章通过 finalizers 来建立 redis instance 和所创建 pod 的关系， 以及处理删除逻辑 1. 创建 redis instance 与 pod 的关系 在 /controllers/helper/redis_helper.go 通过</description></item><item><title>《kubebuilder 从零开始实战》 - 08. Pod 扩容与缩容</title><link>https://typonotes.com/posts/books/kubebuilder-zero-to-one/08-scale-pod/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/kubebuilder-zero-to-one/08-scale-pod/</guid><description>Pod 扩容与缩容 代码在: https://github.com/tangx/kubebuilder-zero-to-one 代码分支越来越多 增/删/改 都有了， 于是选择拆分为 3 个分支。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 扩容 func (r *RedisReconciler) increaseReconcile(ctx context.Context, redis *myappv1.Redis) (ctrl.Result, error) { // ... } // 缩容 func (r *RedisReconciler) decreaseReconcile(ctx context.Context, redis *myappv1.Redis) (ctrl.Result, error) { // ... } // 删除 func (r *RedisReconciler) deleteReconcile(ctx context.Context, redis *myappv1.Redis) (ctrl.Result, error) { // ... } 所谓 扩容/缩容， 在通过 finalizers 管理的时候就是 redis.spec.replicas 与 len(redis.finalizers) 的大小比较。 1 2 3 4 // 缩容 if len(redis.Finalizers) &amp;gt;</description></item><item><title>《kubebuilder 从零开始实战》 - 09. 监听 k8s 事件</title><link>https://typonotes.com/posts/books/kubebuilder-zero-to-one/09-watch-k8s-event/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/kubebuilder-zero-to-one/09-watch-k8s-event/</guid><description>监听 k8s 事件 代码在: https://github.com/tangx/kubebuilder-zero-to-one 之前的代码遗留了一个问题， 当手动通过命令删除 pod 时候， 不会出发 redis.Finalizers 的更新， 也不会重建被删除的 Pod， 实现效果并不好 1 kubectl delete pod pod_name 1. 监听事件 在 /controllers/redis_controller.go 中生成了对象和方法监听 k8s 的事件。 ctrl 创建的 Builder 可以通过 链式 调用方式， 监听多个 k8s 对象的事件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // SetupWithManager sets up the</description></item><item><title>《kubebuilder 从零开始实战》 - 10. 重建被删除的 Pod</title><link>https://typonotes.com/posts/books/kubebuilder-zero-to-one/10-recreate-deleted-pod/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/kubebuilder-zero-to-one/10-recreate-deleted-pod/</guid><description>重建被删除的 Pod 代码在: https://github.com/tangx/kubebuilder-zero-to-one 之前遗留了一个问题， 直接用命令行删除的 Pod 不能被重建。 这次就来解决它。 首先来整理之前遗留的问题故障点在哪里？ 使用命令 kubectl delete 直接删除 pod 的时候， redis.Finalizers 不会变更， 依旧包含被删除的 pod.Name。 在创建 Pod 的时候， 判断 Pod 是否存在使用的是 redis.Finalizers 提供信息， 而 没有判断 k8s 中真实的情况</description></item><item><title>《kubebuilder 从零开始实战》 - 11. 使用 controllerutil 优化代码</title><link>https://typonotes.com/posts/books/kubebuilder-zero-to-one/11-official-package-optimize/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/kubebuilder-zero-to-one/11-official-package-optimize/</guid><description>使用 controllerutil 优化代码 代码在: https://github.com/tangx/kubebuilder-zero-to-one 在之前的代码中， 对于 OwnerReference 和 Finalizers 操作我们自己实现了一些方法。 其实这些操作官方已经封好成包了， 开箱即用。 复制 /controllers/helper 保存为 /controllers/helper2。 前者保存手工代码， 后者保存优化代码。 https://pkg.go.dev/sigs.k8s.io/controller-runtime/pkg/controller/controllerutil Finalizers 操作 之前 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29</description></item><item><title>《kubebuilder 从零开始实战》 - 12. 增加 k8s event 事件支持</title><link>https://typonotes.com/posts/books/kubebuilder-zero-to-one/12-add-event/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/kubebuilder-zero-to-one/12-add-event/</guid><description>增加 event 事件支持 代码在: https://github.com/tangx/kubebuilder-zero-to-one k8s 官方 controller 都实现了 Events 消息信息， 如下 1 2 3 4 5 6 7 kubectl describe deployment k8s-operator-demo-controller-manager Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 15m deployment-controller Scaled up replica set k8s-operator-demo-controller-manager-75cc59d8ff to 1 Normal ScalingReplicaSet 14m deployment-controller Scaled down replica set k8s-operator-demo-controller-manager-b9d9f7886 to 0 我们自定义的 Operator 同样可以实现。 operator 支持 event 在 /controllers/redis_controller.go 中定义 RedisReconcile 的时候， 添加 EventRecord 字段。 1 2 3 4 5 6 7 8 // RedisReconciler reconciles a Redis object type RedisReconciler struct { client.Client Scheme *runtime.Scheme // 添加事件 EventRecord record.EventRecorder } 在 /main.go 中， 创</description></item><item><title>《kubebuilder 从零开始实战》 - 13. 添加 CRD 对象 Status 状态字段</title><link>https://typonotes.com/posts/books/kubebuilder-zero-to-one/13-add-status/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/kubebuilder-zero-to-one/13-add-status/</guid><description>添加 CRD 对象 Status 状态字段 代码在: https://github.com/tangx/kubebuilder-zero-to-one 添加 kd 状态字段 在 /api/v1/redis_types.go 的 RedisStatus 中添加需要展示的字段。 这里添加一个副本数量。 1 2 3 4 5 type RedisStatus struct { // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster // Important: Run &amp;#34;make&amp;#34; to regenerate code after modifying this file Replicas int `json:&amp;#34;replicas&amp;#34;` } 偷懒， 没有在创建或删除 pod 时进行精细控制。 而是使用 defer 在 Reconcile 退出的时候进行一次最终的赋值管理。 1 2 3 4 5 6 7 8 9 10 11 12 13</description></item><item><title>《kubebuilder 从零开始实战》 - 14. CRD 支持 kubectl scale 和 kubectl autoscale 命令</title><link>https://typonotes.com/posts/books/kubebuilder-zero-to-one/14-kubectl-scale-autoscale-support/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/kubebuilder-zero-to-one/14-kubectl-scale-autoscale-support/</guid><description>支持 kubectl scale 和 kubectl autoscale 命令 代码在: https://github.com/tangx/kubebuilder-zero-to-one 在 k8s 自定义资源中有关于 scale 和 hpa 的 subresources 字段， 只有这些字段被定义的时候才能支持 scale 和 autoscale 命令 官方定义如下 https://kubernetes.io/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource 在 kubebuilde 中， 使用 //+kubebuilder:subresource:scale 增加注解， 生成对应的配置。 注意， 未知需要在 //+kubebuilder:subresource:status 下方 1 2 3 //+kubebuilder:object:root=true //+kubebuilder:subresource:status //+kubebuilder:subresource:scale:specpath=.spec.replicas,statuspath=.status.replicas,selectorpath=.status.selector 三个关键字段: specpath: specReplicasPath 指定定制资源内与 scale.spec.replicas 对应的 JSON 路径。 此字段为 必需值 。 只可以使用 .spec 下的 JSON</description></item></channel></rss>
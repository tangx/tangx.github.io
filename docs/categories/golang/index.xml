<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on 老麦的书房</title><link>https://typonotes.com/categories/golang/</link><description>Recent content in golang on 老麦的书房</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 22 May 2025 17:08:43 +0800</lastBuildDate><atom:link href="https://typonotes.com/categories/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Go1.23 Iterators 迭代器</title><link>https://typonotes.com/posts/2025/05/22/go1.23-iterators/</link><pubDate>Thu, 22 May 2025 17:08:43 +0800</pubDate><guid>https://typonotes.com/posts/2025/05/22/go1.23-iterators/</guid><description>Go1.23 Iterators 迭代器 建议点击 查看原文 查看最新内容。 原文链接: https://typonotes.com/posts/2025/05/22/go1.23-iterators/ 在 Go1.23 新引入了一个标准包 迭代器 Iterator 。 可以返回一个 可迭代对象 - 函数， 该对象 接受一个 回调函数 - yield 。 标准包 iter 中包含以下两个类型 Seq, Seq2。 二者都返回了一个 生成器函数 yield function 1 2 3 4 type ( Seq[V any] func(yield func(V) bool) Seq2[K, V any] func(yield func(K, V) bool) ) Seq2 的命名方式看起来很奇怪， 感觉不</description></item><item><title>Cobrautils: 让绑定参数更简单</title><link>https://typonotes.com/posts/2024/03/29/cobrautils-bind-parameters/</link><pubDate>Fri, 29 Mar 2024 08:17:31 +0800</pubDate><guid>https://typonotes.com/posts/2024/03/29/cobrautils-bind-parameters/</guid><description>Cobrautils: 让绑定参数更简单 建议点击 查看原文 查看最新内容。 原文链接: https://typonotes.com/posts/2024/03/29/cobrautils-bind-parameters/ 有群友说， python 命令行绑定参数方便。 本来没什么 还要顺口踩一脚 go 的参数绑定不方便。 这个能忍？ CobraUtils 使用结构体绑定参数 cobra 绝对是命令行库中的第一梯队， kubectl 也是使用这个库实现的。 现在的问题是: 怎么才能 快速方便 的绑定参数呢？ 那就必须用 反射 实</description></item><item><title>几种封装 HTTP Authorization 的分装方式</title><link>https://typonotes.com/posts/2024/01/25/authz-in-http-request/</link><pubDate>Thu, 25 Jan 2024 10:35:44 +0800</pubDate><guid>https://typonotes.com/posts/2024/01/25/authz-in-http-request/</guid><description>几种封装 HTTP Authorization 的分装方式 建议点击 查看原文 查看最新内容。 原文链接: https://typonotes.com/posts/2024/01/25/authz-in-http-request/ 大家都知道， 在做 HTTP 请求的时候， 通常需要提供 账号名和密码， 例如 1 $ curl -u username:password http://api.example.com 其实， 这种就是 HTTP Authentication 中的 Basic 模式(Schema) 翻译一下 首先将账号密码使用 冒号: 链接 随后进行 base64 编码 最后放在 Header 的 Authorization 中。 1 2 $ val=base64(&amp;#34;username:password&amp;#34;) $ curl -H &amp;#34;Authorization: Basic ${username:password} http://api.example.com 除了 Basic 之外</description></item><item><title>Golang 使用 inline 处理 JSON/YAML 内联字段的 2 点注意事项</title><link>https://typonotes.com/posts/2024/01/09/golang-tag-inline/</link><pubDate>Tue, 09 Jan 2024 11:15:10 +0800</pubDate><guid>https://typonotes.com/posts/2024/01/09/golang-tag-inline/</guid><description>Golang 使用 inline 处理 JSON/YAML 内联字段的 2 点注意事项 建议点击 查看原文 查看最新内容。 原文链接: https://typonotes.com/posts/2024/01/09/golang-tag-inline/ 这是一片错误笔记， 没什么高大上的东西。 简单记录一下在 Go 中使用 json 和 yaml 在解析字符串的时候没有太注意的一个点。 以 Json 为例， 通常我们在 struct结构 与 Json结构 的时候是 一一对应 的。 以下几种名字都是我自己取的，</description></item><item><title>如何实现 Http Request Body 多次读取</title><link>https://typonotes.com/posts/2024/01/02/http-request-multiple-times-read/</link><pubDate>Tue, 02 Jan 2024 09:51:33 +0800</pubDate><guid>https://typonotes.com/posts/2024/01/02/http-request-multiple-times-read/</guid><description>如何实现 Http Request Body 多次读取 建议点击 查看原文 查看最新内容。 原文链接: https://typonotes.com/posts/2024/01/02/http-request-multiple-times-read/ 最近在使用 gin 的时候， 踩了一个重复读取的 Request.Body 的坑。 起因是 gin 的 gin.Context{} 提供了 c.Copy() 方法创建副本。 这个方法一直在用， 但不知道从什么时候开始， 一直认为这个方法是 深拷贝， 但 并不完全是 (T_T) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Copy returns a</description></item><item><title>Golang Reflect Interface Deeopcopy</title><link>https://typonotes.com/posts/2023/03/20/golang-reflect-interface-deeopcopy/</link><pubDate>Mon, 20 Mar 2023 23:09:55 +0800</pubDate><guid>https://typonotes.com/posts/2023/03/20/golang-reflect-interface-deeopcopy/</guid><description>「Golang反射实战2」 使用 接口(interface) 实现 深拷贝(deepcopy) 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。 状态: 未更新 原文链接: https://typonotes.com/posts/2023/03/20/golang-reflect-interface-deeopcopy/ interface 接口 deepcopy 的实现 对于 接口 interface{} 就稍微麻烦一点了。 由于 接口 是一组方法的集合， 也就意味着 接口的 底层结构体 是不定的。 无</description></item><item><title>Golang Context 值传递的生产案例(01): 链路追踪</title><link>https://typonotes.com/posts/2023/03/15/golang-context-in-action-trace/</link><pubDate>Wed, 15 Mar 2023 22:14:40 +0800</pubDate><guid>https://typonotes.com/posts/2023/03/15/golang-context-in-action-trace/</guid><description>Golang Context 生产应用案例(01): 链路追踪 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。 状态: 未更新 原文链接: https://typonotes.com/posts/2023/03/15/golang-context-in-action-trace/ 看完本文 了解 链路追踪 和 OpenTelemetry 相关知识 了解 Context 值传递是如何在 链路追踪 的发展历程上登台亮相的。 之前在 Golang 上下文 Context 源码解析(1): 值传递 文章中举了一个例子说明讲解 Context 的值传递</description></item><item><title>「Golang 反射实战」 - 我用 Golang 反射写了一个配置库 - envutils ， 应用再也不会少变量了</title><link>https://typonotes.com/posts/2023/01/27/golang-envutils-config/</link><pubDate>Fri, 27 Jan 2023 09:08:25 +0800</pubDate><guid>https://typonotes.com/posts/2023/01/27/golang-envutils-config/</guid><description>「Golang 反射实战」 - 我用 Golang 反射写了一个配置库 - envutils ， 应用再也不会少变量了 原文链接: https://tangx.in/posts/2023/01/27/golang-envutils-config/ 用习惯了 struct 之后， 我想所有东西都通过 struct 管理。 学习了反射之后， 我总要找点事情做来练习。 于是我整合了 Golang环境变量操作 和 Golang反射， 以及解决了我认为的其他一些配置管理的痛点， 便有了这个项</description></item><item><title>这些关于 Golang timezone 时区的坑， 我已经帮你踩过了</title><link>https://typonotes.com/posts/2023/01/09/golang-timezone-issue/</link><pubDate>Mon, 09 Jan 2023 23:00:30 +0800</pubDate><guid>https://typonotes.com/posts/2023/01/09/golang-timezone-issue/</guid><description>这些关于 Golang timezone 时区的坑， 我已经帮你踩过了 原文链接: https://tangx.in/posts/2023/01/09/golang-timezone-issue/ Golang 中一些不太注意的时区问题 1. time/tzdata 库 Golang 内置的一个时区文件。 可以在程序中任意位置被导入。 导入后， 如果程序 找不到本地 时区文件， 就会使用该库的数据。 本地 指的是 运行环境， 可能是实际的服务器， 也可能是容器。 通常， 应该在 main.go 中被导入。 如果是 库代码 则</description></item><item><title>Golang 库: 为什么 Golang slog 库不支持 Fatal 了</title><link>https://typonotes.com/posts/2023/01/06/why-dont-golang-slog-support-fatal-api/</link><pubDate>Fri, 06 Jan 2023 08:09:33 +0800</pubDate><guid>https://typonotes.com/posts/2023/01/06/why-dont-golang-slog-support-fatal-api/</guid><description>Golang 库: 为什么 Golang slog 库不支持 slog.Fatal API 原文链接: https://tangx.in/posts/2023/01/06/why-dont-golang-slog-support-fatal-api/ 使用 slog 默认不支持 Fatal 如果直接把 slog 当成 log 使用， 会有一点点头疼 1 2 3 4 5 6 7 8 9 10 11 func main() { slog.Debug(&amp;#34;debug&amp;#34;) slog.Info(&amp;#34;info&amp;#34;) slog.Warn(&amp;#34;warn&amp;#34;) slog.Error(&amp;#34;err&amp;#34;, fmt.Errorf(&amp;#34;game over&amp;#34;)) // slog.Fatal(&amp;#34;don&amp;#39;t support&amp;#34;) } // 2023/01/06 07:41:50 INFO info // 2023/01/06 07:41:50 WARN warn // 2023/01/06 07:41:50 ERROR err err=&amp;#34;game over&amp;#34; slog 默认日志级别 是 info， 无法输出 DEBUG 日志。 需要自定义 handler 实现日志级别判断。 参考 Golang 库: 怎么使用 golang slog 设置日志</description></item><item><title>Golang 库: 怎么使用 golang slog 设置日志 Debug 等级</title><link>https://typonotes.com/posts/2023/01/06/how-to-set-debug-level-in-golang-slog/</link><pubDate>Fri, 06 Jan 2023 07:22:12 +0800</pubDate><guid>https://typonotes.com/posts/2023/01/06/how-to-set-debug-level-in-golang-slog/</guid><description>Golang 库: 怎么使用 golang slog 设置日志 Debug 等级 原文链接: https://tangx.in/posts/2023/01/06/how-to-set-debug-level-in-golang-slog/ 在 golang 中， 日志统一 一直都是一个头疼的问题。 在 exp 中， Go 加入了一个 新库 exp/slog ， 希望能转正。 这里有一些关于 slog 的介绍， 可以参考 Go 十年了，终于想起要统一 log 库了！ 使用 slog 习惯误区， 默认日志级别是 Info 如果直接把 slog 当成 log 使用， 可能又一点问题。 1 2 3 4 5 6 7 8 9 10</description></item><item><title>golang deepcopy 的两种实现方式</title><link>https://typonotes.com/posts/2021/12/14/golang-struct-interface-deepcopy/</link><pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/12/14/golang-struct-interface-deepcopy/</guid><description>Golang 实现深拷贝(DeepCopy)的两种方式 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。 状态: 未更新 原文链接: https://typonotes.com/posts/2021/12/14/golang-struct-interface-deepcopy/ golang deepcopy 的两种实现方式 最近在基于 gin 封装 rum-gonic - github web 框架的过程中，遇到了一个问题。 在注册路由的时候传递是 指针对象， 因此造成所有的 request 请求使用相同的 CreateUser 对象, 出现并发</description></item><item><title>经过99次失败后， 我总结了几点 Golang 反射的经验（附源码）</title><link>https://typonotes.com/posts/2021/09/22/golang-reflect/</link><pubDate>Wed, 22 Sep 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/09/22/golang-reflect/</guid><description>经过99次失败后， 我总结了几点 Golang 反射的经验（附源码） golang 反射很好用， 也有很多坑。 代码在: https://github.com/tangx-labs/golang-reflect-demo Kind 和 Type 在 golang 的反射中， 有两个可以表示 类型 的关键字， Kind 和 Type 。 定义覆盖范围 Kind 的定义覆盖范围比 Type 要大。 Kind 在定义上要 更抽象， Type 要更具体。 可以简单理解为， 如果 Kind 是 车 ， 那么 Type 可能是 公交车 、 消防车 内置类型字面</description></item><item><title>太久没写， 都忘记了 golang slice 切片的完整表达式</title><link>https://typonotes.com/posts/2021/09/22/golang-slice-expressions/</link><pubDate>Wed, 22 Sep 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/09/22/golang-slice-expressions/</guid><description>太久没写， 都忘记了 golang slice 切片的完整表达式 原文链接: https://tangx.in/posts/2021/09/22/golang-slice-expressions/ 通常，我们写的 golang slice 边界只有两个数字 slice[1:3] ， 这是一种简单写法。 而完整写法是 三个数字 slice[1:3:5] 简单表达式 一个冒号， 两个参数， 表示 slice 元素的 起止区间 1 a[low:high] 案例代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( &amp;#34;fmt&amp;#34; ) func main() { a := [5]int{1, 2, 3, 4, 5} s := a[1:4] // [2,3,4] fmt.Println(s) s1 :=</description></item><item><title>一篇文章告诉你 golang 环境变量的所有基础操作</title><link>https://typonotes.com/posts/2021/09/06/golang-os-env-operation/</link><pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/09/06/golang-os-env-operation/</guid><description>一篇文章告诉你 golang 环境变量的所有基础操作 原文链接： https://tangx.in/posts/2021/09/06/golang-os-env-operation/ golang 中的环境变量操作都在 os 包下面， 只有很少的几个方法， 而且字面意思也很明确。 所有环境变量操作对象都是 字符串string ， 因此对于 int， bool 类型需要自己实现转换。 golang 程序执行的时候， 是在 linux 系统中 fork 的一种子进程中 golang程序 在 复制了开</description></item><item><title>Golang知识点(defer): 面试经常变量在 defer 中的值， 其实在问变量的作用域</title><link>https://typonotes.com/posts/2021/06/21/golang-defer-func-variables-scope/</link><pubDate>Mon, 21 Jun 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/06/21/golang-defer-func-variables-scope/</guid><description>变量在 defer 中的值， 其实在问变量的作用域 有没有想过， 面试中经常问的 变量在 defer 之后的值， 其实是在问 函数变量的作用域 简单的说， defer 就是将当前操作放入 堆 中， 等待触发 return 的时候再拿出来执行。 符合堆的特色， 先进后出。 从细节来了， 还需要注意 变量 在 defer 中的 作用域 ？ 函数 的 执行操作 是在 入堆前还是后 ？ defer 中的函数</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on 老麦的书房</title><link>https://tangx.in/categories/golang/</link><description>Recent content in golang on 老麦的书房</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 06 Jan 2023 08:09:33 +0800</lastBuildDate><atom:link href="https://tangx.in/categories/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>为什么 Go slog 库不支持 Fatal 了</title><link>https://tangx.in/posts/2023/01/06/why-golang-slog-do-not-support-fatal/</link><pubDate>Fri, 06 Jan 2023 08:09:33 +0800</pubDate><guid>https://tangx.in/posts/2023/01/06/why-golang-slog-do-not-support-fatal/</guid><description>为什么 Go slog 库不支持 Fatal 原文链接: https://tangx.in/posts/2023/01/06/why-golang-slog-do-not-support-fatal/ 使用 slog 习惯误区， 不支持 Fatal 如果直接把 slog 当成 log 使用， 会有一点点头疼 1 2 3 4 5 6 7 8 9 10 11 func main() { slog.Debug(&amp;#34;debug&amp;#34;) slog.Info(&amp;#34;info&amp;#34;) slog.Warn(&amp;#34;warn&amp;#34;) slog.Error(&amp;#34;err&amp;#34;, fmt.Errorf(&amp;#34;game over&amp;#34;)) // slog.Fatal(&amp;#34;don&amp;#39;t support&amp;#34;) } // 2023/01/06 07:41:50 INFO info // 2023/01/06 07:41:50 WARN warn // 2023/01/06 07:41:50 ERROR err err=&amp;#34;game over&amp;#34; slog 默认日志级别 是 info， 无法输出 DEBUG 日志。 需要自定义 handler 实现日志级别判断。 后文详细说。 slog 默认不支持 Fatal API</description></item><item><title>How Golang Slog Library Set Debug Level</title><link>https://tangx.in/posts/2023/01/06/how-golang-slog-library-set-debug-level/</link><pubDate>Fri, 06 Jan 2023 07:22:12 +0800</pubDate><guid>https://tangx.in/posts/2023/01/06/how-golang-slog-library-set-debug-level/</guid><description>How Golang Slog Library Set Debug Level 原文链接: https://tangx.in/posts/2023/01/06/how-golang-slog-library-set-debug-level/ 在 golang 中， 日志统一 一直都是一个头疼的问题。 https://golang.org/x/exp/slog 在 exp 中， Go 加入了一个新库 slog， 希望能转正。 一些关于 slog 的介绍， 可以参考 Go 十年了，终于想起要统一 log 库了！ 使用 slog 习惯误区， 默认日志级别是 Info 如果直接把 slog 当成 log 使用， 1 2 3 4 5 6 7 8 9 10 11 func main() { slog.Debug(&amp;#34;debug&amp;#34;) slog.Info(&amp;#34;info&amp;#34;) slog.Warn(&amp;#34;warn&amp;#34;) slog.Error(&amp;#34;err&amp;#34;, fmt.Errorf(&amp;#34;game over&amp;#34;)) // slog.Fatal(&amp;#34;don&amp;#39;t support&amp;#34;) } // 2023/01/06</description></item><item><title>Golang知识点(defer): 面试经常变量在 defer 中的值， 其实在问变量的作用域</title><link>https://tangx.in/posts/2021/06/21/golang-defer-func-variables-scope/</link><pubDate>Mon, 21 Jun 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/06/21/golang-defer-func-variables-scope/</guid><description>变量在 defer 中的值， 其实在问变量的作用域 有没有想过， 面试中经常问的 变量在 defer 之后的值， 其实是在问 函数变量的作用域 简单的说， defer 就是将当前操作放入 堆 中， 等待触发 return 的时候再拿出来执行。 符合堆的特色， 先进后出。 从细节来了， 还需要注意 变量 在 defer 中的 作用域 ？ 函数 的 执行操作 是在 入堆前还是后 ？ defer 中的函数</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cloudnative on 老麦的书房</title><link>https://typonotes.com/categories/cloudnative/</link><description>Recent content in cloudnative on 老麦的书房</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 25 Mar 2024 16:19:28 +0800</lastBuildDate><atom:link href="https://typonotes.com/categories/cloudnative/index.xml" rel="self" type="application/rss+xml"/><item><title>K8s API 依赖导入链的版本问题</title><link>https://typonotes.com/posts/2024/03/25/k8s-api-import-chain-problem/</link><pubDate>Mon, 25 Mar 2024 16:19:28 +0800</pubDate><guid>https://typonotes.com/posts/2024/03/25/k8s-api-import-chain-problem/</guid><description>K8s API 依赖导入链的版本问题 建议点击 查看原文 查看最新内容。 原文链接: https://typonotes.com/posts/2024/03/25/k8s-api-import-chain-problem/ 1 2 3 4 5 6 7 8 // go.mod // 异常的版本依赖指定和引用 require ( k8s.io/api v0.28.8 k8s.io/client-go v0.28.8 k8s.io/apimachinery v0.28.8 ) 由于依赖链的中的版本问题， 导致 k8s.io 被默认指向了当前最新版本 v0.29.3。 但是出现了一点点小问题， 导致 go mod tidy 失败。 go: github.com/example/kubez/pkg/healthy imports k8s.io/client-go/kubernetes imports k8s.io/client-go/kubernetes/typed/auditregistration/v1alpha1 imports k8s.io/api/auditregistration/v1alpha1: module k8s.io/api@latest found (v0.29.3), but does not contain package k8s.io/api/auditregistration/v1alpha1 go:</description></item><item><title>一个关于 Nodejs Dockerfile 的小优化</title><link>https://typonotes.com/posts/2024/02/20/a-simple-optimizion-for-nodejs-dockerfile/</link><pubDate>Tue, 20 Feb 2024 10:35:46 +0800</pubDate><guid>https://typonotes.com/posts/2024/02/20/a-simple-optimizion-for-nodejs-dockerfile/</guid><description>一个关于 Nodejs Dockerfile 的小优化 建议点击 查看原文 查看最新内容。 原文链接: https://typonotes.com/posts/2024/02/20/a-simple-optimizion-for-nodejs-dockerfile/ 原版 Dockerfile 如下。 1 2 3 4 5 6 7 8 9 10 FROM ${BASE_IMAGE} as env RUN mkdir -p /app &amp;amp;&amp;amp; chown -R node:node /app WORKDIR /app COPY package*.json ./ COPY .npmrc ./ USER node ## 问题在这里， npm install 失败之后， 无法看到具体错误 RUN npm install 在执行完成 npm install 之后没有更多的 错误判断。 如果没有出错， 一切都正常。 往下走就行了。 但是执行出错</description></item><item><title>OpenTelemetry(05): Otel Collector Contrib 添加鉴权支持</title><link>https://typonotes.com/posts/2023/10/07/otel-collector-contrib-with-auth-supportive/</link><pubDate>Sat, 07 Oct 2023 17:19:54 +0800</pubDate><guid>https://typonotes.com/posts/2023/10/07/otel-collector-contrib-with-auth-supportive/</guid><description>OpenTelemetry(05): Otel Collector Contrib 添加鉴权支持 建议点击 查看原文 查看最新内容。 原文链接: https://typonotes.com/posts/2023/10/07/otel-collector-contrib-with-auth-supportive/ 之前我在 OpenTelemetry(1): Golang 接入 OpenTelemetry 完整过程和思路（附源码）- Gin Demo 中提到过， 使用 Otel Collector Contrib 作为中间件 解耦 应用和数据平台。 1. 遇到的困境 此前并没有提到 Otel Collector Contrib 限制接入的问题。 测试的时候在 K8S 集群内部， 服务不对外， 无需鉴权。 但在团队内部推广并上线之后</description></item><item><title>Opentelmetry(2): 【内部分享】 从入门到精通</title><link>https://typonotes.com/posts/2023/08/29/opentelmetry-introduce-techsharing/</link><pubDate>Tue, 29 Aug 2023 17:19:36 +0800</pubDate><guid>https://typonotes.com/posts/2023/08/29/opentelmetry-introduce-techsharing/</guid><description>Opentelmetry(2): 【内部分享】 从入门到精通 建议点击 查看原文 查看最新内容。 原文链接: https://typonotes.com/posts/2023/08/29/opentelmetry-introduce-techsharing/ 01. 我们为什么需要做链路追踪 当 服务逻辑复杂、 调用链条过长 ， 甚至夸多个部门协作时。 一个请求 从被接受到应答 中间过程就是个 黑盒， 如果出现不稳定的情况， 例如 响应慢， 相应错误 的时候， 排查起来效率低下， 甚至无法排查。 如果想要解</description></item><item><title>OpenTelemetry(1): Golang 接入 OpenTelemetry 完整过程和思路（附源码）- Gin Demo</title><link>https://typonotes.com/posts/2023/08/14/golang-opentelemetry-notes/</link><pubDate>Mon, 14 Aug 2023 16:44:54 +0800</pubDate><guid>https://typonotes.com/posts/2023/08/14/golang-opentelemetry-notes/</guid><description>Golang 接入 OpenTelemetry 完整过程和思路（附源码） - Gin Demo 建议点击 查看原文 查看最新内容。 原文链接: https://typonotes.com/posts/2023/08/14/golang-opentelemetry-notes/ 为了更方便的查看代码， 建议直接跳转到 Github 仓库： https://github.com/tangx/opentelemetry-gin-demo 使用笔记 1. 使用 Otel-Collect-Contrib 初始化 trace.Provider 这里使用 app -&amp;gt; collector-contrib 进行转发， 应用不直接对后端的存储。 适配性 更高。 collector-contrib 最常见的两种协议 grpc / http(s)。 传入 endpoint 地址进行初始化 Provid</description></item><item><title>kubernetes集群中夺命的5秒DNS延迟</title><link>https://typonotes.com/posts/2023/08/05/k8s-dns-5s-resolv/</link><pubDate>Sat, 05 Aug 2023 01:05:52 +0800</pubDate><guid>https://typonotes.com/posts/2023/08/05/k8s-dns-5s-resolv/</guid><description>kubernetes集群中夺命的5秒DNS延迟 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。 状态: 未更新 原文链接: https://typonotes.com/posts/2023/08/05/k8s-dns-5s-resolv/ kubernetes集群中夺命的5秒DNS延迟 问题原因 相关文章 kubernetes集群中夺命的5秒DNS延迟 破案：Kubernetes/Docke</description></item><item><title>《容器云平台排错一览图》</title><link>https://typonotes.com/posts/2023/06/27/cloudnative-k8s-debug-flow/</link><pubDate>Tue, 27 Jun 2023 10:35:12 +0800</pubDate><guid>https://typonotes.com/posts/2023/06/27/cloudnative-k8s-debug-flow/</guid><description>《容器云平台排错一览图》 建议点击 查看原文 查看最新内容。 原文链接: https://typonotes.com/posts/2023/06/27/cloudnative-k8s-debug-flow/ 这张 《容器云平台排错一览图》 不仅 逻辑清晰的为我们提供了 排错思路、流程 和 check list。 而且 通过不同颜色， 非常贴心的为我们提供常用建议。 黑色： 命令 绿色： 直接修复方案 蓝色： 建议 感谢作者。 图片来源： learnk8s.io 绘制/勘误： Spark 点击下载 高</description></item><item><title>云原生: 为开发朋友解答的 100 个问题</title><link>https://typonotes.com/posts/2023/03/22/docker-100-questions-for-developers/</link><pubDate>Wed, 22 Mar 2023 11:01:51 +0800</pubDate><guid>https://typonotes.com/posts/2023/03/22/docker-100-questions-for-developers/</guid><description>云原生: 为开发朋友解答的 100 个问题 如果在 公众号 文章发现状态为 已更新， 建议点击 查看原文 查看最新内容。 状态: 未更新 原文链接: https://typonotes.com/posts/2023/03/22/docker-100-questions-for-developers/ 1. 镜像与服务 1.1. 容器内服务监听地址 0.0.0.0 用 0.0.0.0 是最省事的方法。 如果不嫌弃麻烦， 程序可以自己获取网卡地址 监听本地IP。 通常在开发的时候， 在本地调试喜欢用 127.0.0.1</description></item><item><title>OpenTelemetry(3): Collector Contrib 配置接入 Aliyun SLS Trace 服务</title><link>https://typonotes.com/posts/2022/12/23/aliyun-sls-trace-configuration/</link><pubDate>Fri, 23 Dec 2022 18:49:12 +0800</pubDate><guid>https://typonotes.com/posts/2022/12/23/aliyun-sls-trace-configuration/</guid><description>OpenTelemetry(3): Collector Contrib 配置接入 Aliyun SLS Trace 服务 在 Opentelmetry(2): 【内部分享】 从入门到精通 中提到， 应用通过 OpenTelemetry Collector Contrib 将采集到的数据转发到 任意后端程序。 阿里云提供了一个 SLS Trace 服务 ， 类似于 Jaeger， 可以提供服务的观测性。 1. 创建 SLS Trace 服务 创建新实例之后， 可以看到如下图 其中标记的 1，2，3 之后 授权 和 访问 需要用到的。 除了这几个参数</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>library on 老麦的书房</title><link>https://typonotes.com/tags/library/</link><description>Recent content in library on 老麦的书房</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 29 Nov 2024 19:21:45 +0800</lastBuildDate><atom:link href="https://typonotes.com/tags/library/index.xml" rel="self" type="application/rss+xml"/><item><title>Python: 关于 Package 和 Module 快速入门</title><link>https://typonotes.com/posts/2024/11/29/python-package-module-quick-start/</link><pubDate>Fri, 29 Nov 2024 19:21:45 +0800</pubDate><guid>https://typonotes.com/posts/2024/11/29/python-package-module-quick-start/</guid><description>Python: 关于 Package 和 Module 快速入门 建议点击 查看原文 查看最新内容。 原文链接: https://typonotes.com/posts/2024/11/29/python-package-module-quick-start/ 什么是 包 (Package) 如果一个目录中有 __init__.py ， 那这个目录就是 包 Package 什么是 模块 (Module) xxx.py 文件就是模块 怎么引用自定义包 把 包路径 使用 sys.path.append(xxx) 添加后， 就可以使用 1 2 3 4 5 6 7 8 9 10 11 # import {Package} from x.Package import Module print(f&amp;#34;Module.Attribute&amp;#34;) from x.Package.Module import Attribute print(f&amp;#34;{Attribute}&amp;#34;) # 别名 from x.Package.Module import Attribute as attr print(f&amp;#34;{attr}&amp;#34;) 不能使用 连续的 . 结构 1 2 import x.Package</description></item><item><title>Golang 库: 为什么 Golang slog 库不支持 Fatal 了</title><link>https://typonotes.com/posts/2023/01/06/why-dont-golang-slog-support-fatal-api/</link><pubDate>Fri, 06 Jan 2023 08:09:33 +0800</pubDate><guid>https://typonotes.com/posts/2023/01/06/why-dont-golang-slog-support-fatal-api/</guid><description>Golang 库: 为什么 Golang slog 库不支持 slog.Fatal API 原文链接: https://tangx.in/posts/2023/01/06/why-dont-golang-slog-support-fatal-api/ 使用 slog 默认不支持 Fatal 如果直接把 slog 当成 log 使用， 会有一点点头疼 1 2 3 4 5 6 7 8 9 10 11 func main() { slog.Debug(&amp;#34;debug&amp;#34;) slog.Info(&amp;#34;info&amp;#34;) slog.Warn(&amp;#34;warn&amp;#34;) slog.Error(&amp;#34;err&amp;#34;, fmt.Errorf(&amp;#34;game over&amp;#34;)) // slog.Fatal(&amp;#34;don&amp;#39;t support&amp;#34;) } // 2023/01/06 07:41:50 INFO info // 2023/01/06 07:41:50 WARN warn // 2023/01/06 07:41:50 ERROR err err=&amp;#34;game over&amp;#34; slog 默认日志级别 是 info， 无法输出 DEBUG 日志。 需要自定义 handler 实现日志级别判断。 参考 Golang 库: 怎么使用 golang slog 设置日志</description></item><item><title>Golang 库: 怎么使用 golang slog 设置日志 Debug 等级</title><link>https://typonotes.com/posts/2023/01/06/how-to-set-debug-level-in-golang-slog/</link><pubDate>Fri, 06 Jan 2023 07:22:12 +0800</pubDate><guid>https://typonotes.com/posts/2023/01/06/how-to-set-debug-level-in-golang-slog/</guid><description>Golang 库: 怎么使用 golang slog 设置日志 Debug 等级 原文链接: https://tangx.in/posts/2023/01/06/how-to-set-debug-level-in-golang-slog/ 在 golang 中， 日志统一 一直都是一个头疼的问题。 在 exp 中， Go 加入了一个 新库 exp/slog ， 希望能转正。 这里有一些关于 slog 的介绍， 可以参考 Go 十年了，终于想起要统一 log 库了！ 使用 slog 习惯误区， 默认日志级别是 Info 如果直接把 slog 当成 log 使用， 可能又一点问题。 1 2 3 4 5 6 7 8 9 10</description></item></channel></rss>
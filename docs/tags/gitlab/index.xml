<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gitlab on 老麦的书房</title><link>https://typonotes.com/tags/gitlab/</link><description>Recent content in gitlab on 老麦的书房</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 04 Mar 2022 18:44:29 +0800</lastBuildDate><atom:link href="https://typonotes.com/tags/gitlab/index.xml" rel="self" type="application/rss+xml"/><item><title>Gitlab 在不同 job 之间传递变量</title><link>https://typonotes.com/posts/2022/03/04/pass-an-environment-variable-to-another-job/</link><pubDate>Fri, 04 Mar 2022 18:44:29 +0800</pubDate><guid>https://typonotes.com/posts/2022/03/04/pass-an-environment-variable-to-another-job/</guid><description>在 gitlab 中， 不同 job 之间的变量是不能直接传递的。 但如果有需求， 则必须要借助 artifacts:reports:dotenv 实现。 在 job1 中保存在 script 下执行命令， 保存到 xxx.env 文件中。 将变量已 k=v 的形式保存 每行一个 不支持换行符 使用 artifacts:reports:dotenv 传递文件 在后续 job 中， 会自动加载 job1 传递 xxx.env 中的变量键值对。 另外如果在后续 job 中定义了同名变量，则这些变量值将被覆盖， 以 xxx.env 中</description></item><item><title>gitlab shell runner</title><link>https://typonotes.com/posts/2021/09/18/gitlab-shell-runner/</link><pubDate>Sat, 18 Sep 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/09/18/gitlab-shell-runner/</guid><description>快速创建 gitlab shell runner 真没想道有一天， 我居然会创建 gitlab shell runner 。 环境太难管理了 创建 gitlab shell runner 实话实说， gitlab 现在的用户体验太好了。 根本不需要到处去搜文档，直接在 runner 管理界面就可以找到， 还贴心的给你准备了全套， 一键复制粘贴搞定。 https://git.example.com/admin/runners 点击 Show Runner installation instructions 可以看到多种 runner 的配置。 在默认的基础上， 根据实际情况优化一下。 1 2</description></item><item><title>docker runner 配置编译环境的大文件依赖</title><link>https://typonotes.com/posts/2021/09/10/gitlab-docker-runner-with-huge-build-dependence-files/</link><pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/09/10/gitlab-docker-runner-with-huge-build-dependence-files/</guid><description>docker runner 配置编译环境的大文件依赖 需求简介： 现在要做某个 arm 平台的的交叉编译环境， 交叉编译依赖和工具包大小 5G 左右， 特别大。 如果按照以往的方式， 直接将 编译依赖和工具 直接打包到编译镜像中， 会有很多麻烦。 单 layer 过大 docker 单层 layer 限制为 5G。 镜像升级迭代 浪费空间 。 如果镜像上层升级或者依赖变化， 整个 layer 不能</description></item><item><title>gitlab-runner-build not found in path</title><link>https://typonotes.com/posts/2021/09/10/gitlab-runner-build-not-found-in-path/</link><pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/09/10/gitlab-runner-build-not-found-in-path/</guid><description>&amp;quot;gitlab-runner-build&amp;quot;: executable file not found in $PATH 在搭建 gitlab-runner 的过程中，报错如下 1 ERROR: Job failed (system failure): prepare environment: Error response from daemon: OCI runtime create failed: container_linux.go:370: starting container process caused: exec: &amp;#34;gitlab-runner-build&amp;#34;: executable file not found in $PATH: unknown (exec.go:57:0s). Check https://docs.gitlab.com/runner/shells/index.html#shell-profile-loading for more information 因为在 environment 中 扩展了 PATH 而导致 gitlab-runner-helper 中的 PATH 出现了异常。 从而导致 gitlab-runner-build 这个脚本（命令） 无法被找到。 原因分析 在 gitlab 的定义中 environment 的行为有两种 ， append(扩展) 或 overwrite(覆盖)。</description></item><item><title>GitlabCI 使用多个 Runner 执行特定 JOB</title><link>https://typonotes.com/posts/2021/09/06/gitlab-ci-under-multiple-runners/</link><pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/09/06/gitlab-ci-under-multiple-runners/</guid><description>GitlabCI 使用多个 Runner 执行特定 JOB 在 Gitlab CI 中，Runner 是 Job 的执行器， 也就是说 Job 的运行环境， 就是 Runner 的环境。 那么， 怎么将同一个 gitlab ci 中的 Job 运行在不同的 Runner 上呢？ 例如， 根据 操作系统 区分， job1 运行在 windows 上， job2 运行在 linux 上， 诸如此类。 使用 TAG 指定 runner 其实很简单， gitlab ci 中， 可以通过指定 tags 来设定运行条件， 满足了 tag 才能被</description></item><item><title>分支删除触发 gitlab CI</title><link>https://typonotes.com/posts/2021/06/30/gitlab-ci-trigger-when-branch-deleted/</link><pubDate>Wed, 30 Jun 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/06/30/gitlab-ci-trigger-when-branch-deleted/</guid><description>分支删除触发 gitlab CI 使用 environment , 在 gitlab branch 被删除的时候，触发 CI Stopping an environment 尝试在 JOB A 中申明一个变量，并停止。 使用 on_stop action 动作, 在删除分支时(同时删除变量), 触发运行 JOB B Stop an environment when a branch is deleted Stop an environment when a branch is deleted GitLab 在 CI 中配置一个 环境变量 , 当 branch 被删除的时候清理该 环境变量， 触发 on_stop 动作， 需求。 随后这段代码是节选，在 delpoy_action job</description></item><item><title>我用写了一个 gitlab 代码合并机器人， 帮老板每个月省了 100 万（附源码）</title><link>https://typonotes.com/posts/2021/06/16/gitlab-mergebot/</link><pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/06/16/gitlab-mergebot/</guid><description>我用写了一个 gitlab 代码合并机器人， 帮老板每个月省了 100 万 原文链接: https://tangx.in/posts/2021/06/16/gitlab-mergebot/ gitlab merge request robot 是一个 golang 编写的 gitlab mr 请求处理扩展服务。 由于 gitlab(free plan) 的 Merge Request 功能有限， 不能支持多人 Code Reivew。 因此引入第三方机器人进行 MR 合法性仲裁。 设计思路 目标的安全: 使用 目标项目和分支 中的 .mergebot.yml 配置作为机器人判定配置 有意义的文字信息:</description></item><item><title>gitlab-ci 配置复用 - reference tags</title><link>https://typonotes.com/posts/2021/03/12/gitlab-ci-reference-tags/</link><pubDate>Fri, 12 Mar 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/03/12/gitlab-ci-reference-tags/</guid><description>gitlab-ci 配置复用 - reference tags 在 GitLab 13.9 中增加了一个新的关键字 !reference。 这个关键字可以在任意位置复用已存在的配置。 1 2 3 4 # tree ci/setup.yml .gitlab-ci.yml ci/setup.yml 1 2 3 4 5 6 # 以 . 开头的 job 名称为 隐藏job ， 将在 ci 中将被忽略 # https://docs.gitlab.com/ee/ci/yaml/README.html#hide-jobs .setup: image: hub-dev.rockontrol.com/docker.io/library/alpine:3.12 script: - echo creating environment .gitlab.ci.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36</description></item><item><title>5 分钟Gitlab - 安装 Gitlab</title><link>https://typonotes.com/posts/2020/12/07/install-gitlab/</link><pubDate>Mon, 07 Dec 2020 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2020/12/07/install-gitlab/</guid><description>5 分钟Gitlab - 安装 Gitlab Gitlab 是巴啦啦啦啦一大堆。 好处很多。 选型 即使不准备付费， 也选 GitlabEE（企业版本）。 ee 版本免费授权 ee 版本默认开放 ce （社区版） 所有功能。 启用高级功能只需付费购买授权即可。 https://about.gitlab.com/install/ce-or-ee/?distro=ubuntu 准备 准备一台虚拟机， 假设为 ubuntu20.04 操作系统。 根据需要，挂载多个数据盘 默认 /var/opt/gitlab (建议独立) 数</description></item><item><title>gitlab 使用青云 qingstor 对象存储作为存储</title><link>https://typonotes.com/posts/2020/04/23/gitlab-storage-with-qingstor/</link><pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2020/04/23/gitlab-storage-with-qingstor/</guid><description>gitlab 使用青云 qingstor 对象存储作为存储 使用 s3 compatible 模式， 腾讯云、阿里云、华为云、青云 都可以实现。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # https://docs.gitlab.com/ce/administration/job_artifacts.html gitlab_rails[&amp;#39;artifacts_enabled&amp;#39;] = true gitlab_rails[&amp;#39;artifacts_object_store_enabled&amp;#39;] = true gitlab_rails[&amp;#39;artifacts_object_store_remote_directory&amp;#39;] = &amp;#34;gitlab-storage-artifacts&amp;#34; gitlab_rails[&amp;#39;artifacts_object_store_connection&amp;#39;] = { # s3v4 compatible mode # https://gitlab.com/gitlab-org/charts/gitlab/-/blob/master/examples/objectstorage/rails.minio.yaml &amp;#39;provider&amp;#39; =&amp;gt; &amp;#39;AWS&amp;#39;, &amp;#39;region&amp;#39; =&amp;gt; &amp;#39;us-east-1&amp;#39;, &amp;#39;aws_access_key_id&amp;#39; =&amp;gt; &amp;#39;ACID_XXXXXXXXXXXXXXXXX&amp;#39;, &amp;#39;aws_secret_access_key&amp;#39; =&amp;gt; &amp;#39;ACKEY_YYYYYYYYYYYYYYYY&amp;#39;, &amp;#39;aws_signature_version&amp;#39; =&amp;gt; 4, &amp;#39;host&amp;#39; =&amp;gt; &amp;#39;s3.pek3b.qingstor.com&amp;#39;, &amp;#39;endpoint&amp;#39; =&amp;gt; &amp;#34;http://s3.pek3b.qingstor.com&amp;#34;, &amp;#39;path_style&amp;#39; =&amp;gt; true }</description></item></channel></rss>
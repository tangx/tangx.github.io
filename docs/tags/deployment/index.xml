<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>deployment on 老麦的书房</title><link>https://tangx.in/tags/deployment/</link><description>Recent content in deployment on 老麦的书房</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 10 Jan 2023 10:28:03 +0800</lastBuildDate><atom:link href="https://tangx.in/tags/deployment/index.xml" rel="self" type="application/rss+xml"/><item><title>开发 k8s 管理平台 - k8sailor 14. 一些前后端代码优化</title><link>https://tangx.in/posts/books/k8sailor/chapter02/14-some-optimize/</link><pubDate>Tue, 10 Jan 2023 10:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/k8sailor/chapter02/14-some-optimize/</guid><description>开发 k8s 管理平台 - k8sailor 14. 一些前后端代码优化 原文地址: https://tangx.in/posts/books/k8sailor/chapter02/14-some-optimize/ tag: https://github.com/tangx/k8sailor/tree/feat/14-some-optimize 将 LabelSelector 转换为 Selector client-go 提供了一个方法， 可以将 Resource 中的 LabelSelector 转换为 Selector, 并且 Selector 结构提供了一些常用的方法。 如 String 1 2 3 4 5 6 7 8 9 import ( metav1 &amp;#34;k8s.io/apimachinery/pkg/apis/meta/v1&amp;#34; ) func() { selector, _ := metav1.LabelSelectorAsSelector(dep.Spec.Selector) x := selector.String() fmt.Println(x) }() 因此在使用 GetXXXByLabels 时， api 层 可以考虑 接收 map[string]string 类型的参数。 而在 biz 层应该将 不同类型 的参数 统一 转换为格式</description></item><item><title>开发 k8s 管理平台 - k8sailor 15. 根据名字删除 deployment 和 pod</title><link>https://tangx.in/posts/books/k8sailor/chapter02/15-delete-deployment-and-pod-by-name/</link><pubDate>Tue, 10 Jan 2023 10:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/k8sailor/chapter02/15-delete-deployment-and-pod-by-name/</guid><description>开发 k8s 管理平台 - k8sailor 15. 根据名字删除 deployment 和 pod 原文地址: https://tangx.in/posts/books/k8sailor/chapter02/15-delete-deployment-and-pod-by-name/ tag: https://github.com/tangx/k8sailor/tree/feat/15-delete-deployment-and-pod-by-name 调用 k8s api 没什么好说的。 k8sdao 1 2 3 4 5 func DeleteDeploymentByName(ctx context.Context, namespace string, name string) error { opts := metav1.DeleteOptions{} return clientset.AppsV1().Deployments(namespace).Delete(ctx, name, opts) } biz 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type DeleteDeploymentByNameInput struct { Name string `uri:&amp;#34;name&amp;#34;` Namespace string `query:&amp;#34;namespace&amp;#34;` } // DeleteDeploymentByName 根据名字删除 deployment func DeleteDeploymentByName(ctx context.Context, input DeleteDeploymentByNameInput) error { err := k8sdao.DeleteDeploymentByName(ctx, input.Namespace, input.Name) if err != nil { return fmt.Errorf(&amp;#34;k8s internal error: %w&amp;#34;, err) } return nil } api 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func handlerDeleteDeploymentByName(c</description></item><item><title>开发 k8s 管理平台 - k8sailor 16. 创建 Deployment</title><link>https://tangx.in/posts/books/k8sailor/chapter02/16-create-deployment/</link><pubDate>Tue, 10 Jan 2023 10:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/k8sailor/chapter02/16-create-deployment/</guid><description>开发 k8s 管理平台 - k8sailor 16. 创建 Deployment 原文地址: https://tangx.in/posts/books/k8sailor/chapter02/16-create-deployment/ tag: https://github.com/tangx/k8sailor/tree/feat/16-create-deployment 使用 kubectl 命令创建如下 1 kubectl create deployment my-nginx-5 --image=nginx:alpine --replicas=3 --port=80 创建成功后查看结果， 大部分参数为默认参数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # kgd -o yaml my-nginx-5 apiVersion: apps/v1 kind: Deployment metadata: labels: app: my-nginx-5 # 根据 deployment 自动匹配名字自动生成 name: my-nginx-5 # 用户指定 namespace: default # 用户选择，默认为当前 namespace spec: progressDeadlineSeconds: 600 # 默认</description></item><item><title>开发 k8s 管理平台 - k8sailor 17. Pod 的阶段(phase)与状态(status)</title><link>https://tangx.in/posts/books/k8sailor/chapter02/17-pod-phase-and-status/</link><pubDate>Tue, 10 Jan 2023 10:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/k8sailor/chapter02/17-pod-phase-and-status/</guid><description>开发 k8s 管理平台 - k8sailor 17. Pod 的阶段(phase)与状态(status) 原文地址: https://tangx.in/posts/books/k8sailor/chapter02/17-pod-phase-and-status/ Pod 的生命周期 https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/ Pod 的 Status 不是 Phase。 Pod 的 Status 需要根据 Pod 中的 ContainerStatuses 进行计算得到。 Phase 阶段 描述 Pending（悬决） Pod 已被 Kubernetes 系统接受，但有一个或者多个容器尚未创建亦未运行。此阶段包括等待 Pod 被调度的时间和通过网络下载镜</description></item><item><title>开发 k8s 管理平台 - k8sailor 19. 为 Deployment 创建 Service</title><link>https://tangx.in/posts/books/k8sailor/chapter02/19-create-service/</link><pubDate>Tue, 10 Jan 2023 10:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/k8sailor/chapter02/19-create-service/</guid><description>开发 k8s 管理平台 - k8sailor 19. 为 Deployment 创建 Service 原文地址: https://tangx.in/posts/books/k8sailor/chapter02/19-create-service/ tag: https://github.com/tangx/k8sailor/tree/feat/19-create-service https://kubernetes.io/zh/docs/concepts/services-networking/service/#externalname 1 2 3 kubectl create service clusterip nginx-web --clusterip=&amp;#34;port:targetPort&amp;#34; kubectl create service clusterip nginx-web --clusterip=&amp;#34;8082:80&amp;#34; kubectl create service nodeport nginx-web --clusterip=&amp;#34;8081:80&amp;#34; 需要注意, 使用 kubectl get service 查看到的 Ports 的展示结果为 port:nodePort， 而 targetPort 不展示。 1 2 3 # kubectl get service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE demo-nginx-nodeport-3 NodePort 10.43.181.29 &amp;lt;none&amp;gt; 80:32425/TCP 4s port, targetPort, nodePort 端口映射中的四个 比较关键 的要素: name: 避免端口相同时，默认名字冲突 port:</description></item><item><title>开发 k8s 管理平台 - k8sailor 20. 为 Deployment 创建 Ingress</title><link>https://tangx.in/posts/books/k8sailor/chapter02/20-create-ingress/</link><pubDate>Tue, 10 Jan 2023 10:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/k8sailor/chapter02/20-create-ingress/</guid><description>开发 k8s 管理平台 - k8sailor 20. 为 Deployment 创建 Ingress 原文地址: https://tangx.in/posts/books/k8sailor/chapter02/01-install-k3s-cluster/ tag: https://github.com/tangx/k8sailor/tree/feat/20-create-ingress k8s ingress https://kubernetes.io/zh/docs/concepts/services-networking/ingress/ 1 2 3 4 # Create an ingress with a default backend kubectl create ingress ingdefault --class=default \ --default-backend=defaultsvc:http \ --rule=&amp;#34;foo.com/*=svc:8080,tls=secret1&amp;#34; --dry-run -o yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: creationTimestamp: null name: ingdefault spec: defaultBackend: service: name: defaultsvc port: name: http ingressClassName: default rules: - host: foo.com http: paths: - backend: service: name: svc port: number: 8080 path: / pathType: Prefix # 匹配方式 tls: - hosts: - foo.com secretName: secret1 status: loadBalancer: {} 路径类型 Ingress 中的每个</description></item></channel></rss>
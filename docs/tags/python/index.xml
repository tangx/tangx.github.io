<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on 老麦的书房</title><link>https://typonotes.com/tags/python/</link><description>Recent content in python on 老麦的书房</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 21 Nov 2024 11:30:43 +0800</lastBuildDate><atom:link href="https://typonotes.com/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Python 日志库: Loguru</title><link>https://typonotes.com/posts/2024/11/21/python-loguru/</link><pubDate>Thu, 21 Nov 2024 11:30:43 +0800</pubDate><guid>https://typonotes.com/posts/2024/11/21/python-loguru/</guid><description>Python 日志库: Loguru 建议点击 查看原文 查看最新内容。 原文链接: https://typonotes.com/posts/2024/11/21/python-loguru/ loguru 是一款常用的 python 日志库。 https://loguru.readthedocs.io/en/stable/overview.html 注意: loguru 没有 fatal， 而是 critical 安装 1 pip install loguru 基础使用 1 2 3 4 5 6 7 8 9 10 from loguru import logging as log ## 设置格式 logger.add(&amp;#34;file.log&amp;#34;, format=&amp;#34;{time} {level} {message}&amp;#34;, level=&amp;#34;INFO&amp;#34;) ## 设置 level logger.level(&amp;#34;ERROR&amp;#34;) # 注意， 不支持小写 logger.info(&amp;#34;Hello, World!&amp;#34;) logger.critical(&amp;#34;This is a critical message!&amp;#34;) 装饰器用法 1 2 3 4 @logger.catch def test_logger(x: int): log.info(&amp;#34;This is a test logger function!&amp;#34;) return 10 / x 绑定额外参</description></item><item><title>windows 下为 python 安装 win_inet_pton</title><link>https://typonotes.com/posts/2016/11/29/python-libaray-win_inet_pton/</link><pubDate>Tue, 29 Nov 2016 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2016/11/29/python-libaray-win_inet_pton/</guid><description>windows 下为 python 安装 win_inet_pton AttributeError: &amp;lsquo;module&amp;rsquo; object has no attribute &amp;lsquo;inet_pton&amp;rsquo; 我在windows下使用的是python 2.7.11; 自带的socket是不包含inet_pton方法的. 因此, 在做socket代理的时候, socket调用 inet_pton方法会报错, 提示 AttributeError: 'module' object has no attribute 'inet_pton' . windows 使用 socket 报错: File &amp;#34;E:Python27libsite-packagessocks.py&amp;#34;, line 482, in _SOCKS5_request resolved = self._write_SOCKS5_address(dst, writer) File &amp;#34;E:Python27libsite-packagessocks.py&amp;#34;, line 517, in _write_SOCKS5_address addr_bytes = socket.inet_pton(family, host) AttributeError: &amp;#39;module&amp;#39;</description></item><item><title>使用 python 做网页爬虫 目录</title><link>https://typonotes.com/posts/2016/11/29/python-crawler-catalogue/</link><pubDate>Tue, 29 Nov 2016 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2016/11/29/python-crawler-catalogue/</guid><description>使用python做爬虫 本文是自己在做python爬虫时候的笔记. 目录是从百度文库中找到的, 包含了爬虫基础的方方面面. 各种分类练习代码放在了github上. 本文所有代码就基于 windows 版本的python 2.7.11 x86 1. 最基本抓站 对于抓取的对象, 都会使用正则方式进行匹配。 编写正则的一个小技巧： 1.将整</description></item><item><title>在 python 中使用 opener 进行网页访问</title><link>https://typonotes.com/posts/2016/11/29/python-urllib2-opener-usage/</link><pubDate>Tue, 29 Nov 2016 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2016/11/29/python-urllib2-opener-usage/</guid><description>在 python 中使用 opener 进行网页访问 在网页访问中, urllib2 提供了很多 handler, 并且默认支持 http 访问的。因此, 我们可以使用 http handler 初始化一个 opener。 其他的所支持的模式, 我们可以通过 opener.add_handler(handler) 添加。 1 2 3 4 5 6 # function get_opener() # 后面案例需要调用这个方法 import urllib2 url_abs=&amp;#39;http://ip.cn&amp;#39; opener=urllib2.build_opener(urllib2.HTTPHandler()) resp=opener.open(url_abs) return opener 使用opener处理表单 和 cookie 如果遇到需要登录的网站, 可能就需要</description></item><item><title>python matplatlib 格式化坐标轴时间 datetime</title><link>https://typonotes.com/posts/2016/11/28/python_matplotlib_xaxis_datetime_format/</link><pubDate>Mon, 28 Nov 2016 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2016/11/28/python_matplotlib_xaxis_datetime_format/</guid><description>python matplatlib 格式化坐标轴时间 datetime 使用 matplatlib.pyploy 可以非常方便的将数组转换成时间。但是，如果是时间 datetime.datetime() 作为坐标轴，如果不对时间进行优化，将会显得非常紧凑。 对坐标轴时间进行优化，用到的库为 matplatlib.dates。主要代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36</description></item><item><title>python 中使用 shutil 实现文件或目录的复制、删除、移动</title><link>https://typonotes.com/posts/2016/11/24/python-libaray-shutil-shell-command-for-python/</link><pubDate>Thu, 24 Nov 2016 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2016/11/24/python-libaray-shutil-shell-command-for-python/</guid><description>python 中使用 shutil 实现文件或目录的复制、删除、移动 shutil 模块 提供了多个针对文件或文件集合的高等级操作。 尤其是，文件的复制和删除操作。 对于独立文件的操作， 参考 os 模块 警告： 即使是更高等级的文件复制功能 ( shutil.copy(), shutil.copy2() ) 也不能复制所有文件的元数据(metadata)。 在 POSIX 平台上，这意味着文件的属主和用户组会</description></item><item><title>python 字典与 json 异同</title><link>https://typonotes.com/posts/2016/11/17/python-json-usage/</link><pubDate>Thu, 17 Nov 2016 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2016/11/17/python-json-usage/</guid><description>json 与 dict 从结构上来看， json 字符出与 python 字典看起来很相似，都是大括号 {} 括起来的键值对 {key:value}。 s='{&amp;quot;number&amp;quot;:10,&amp;quot;map&amp;quot;:&amp;quot;china&amp;quot;,&amp;quot;10&amp;quot;:&amp;quot;the number&amp;quot;}' 该字符串可以通过**字符串转字典 eval(s) 也可以通过json转字典 json.loads(s) **方式转换成字典 s=&amp;#39;{&amp;#34;number&amp;#34;:10,&amp;#34;map&amp;#34;:&amp;#34;china&amp;#34;,&amp;#34;10&amp;#34;:&amp;#34;the number&amp;#34;}&amp;#39; s_d=eval(s) print s_d # {&amp;#39;map&amp;#39;: &amp;#39;china&amp;#39;, &amp;#39;number&amp;#39;: 10, &amp;#39;10&amp;#39;: &amp;#39;the number&amp;#39;} import json s_j=json.loads(s) print s_j # {u&amp;#39;map&amp;#39;: u&amp;#39;china&amp;#39;, u&amp;#39;number&amp;#39;: 10, u&amp;#39;10&amp;#39;: u&amp;#39;the number&amp;#39;} s_d is s_j # False s_d == s_j # True print type(s_d) # &amp;lt;type &amp;#39;dict&amp;#39;&amp;gt; 然而差别在于： 引</description></item><item><title>使用python生成base64编码和qrcode二维码</title><link>https://typonotes.com/posts/2016/11/16/python-qrcode-base64-usage/</link><pubDate>Wed, 16 Nov 2016 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2016/11/16/python-qrcode-base64-usage/</guid><description>使用python对字符串进行base64编码以及生成字符串qrcode二维码 最近将ss服务器搬到免费docker上面去了。由于是免费的，每次容器重启的时候都会重新绑定服务器地址和容器端口。然而作为一个懒鬼，并不想每次都手动复制粘贴这些信息，于是新需求就是docker容器服务绑定完</description></item><item><title>windows 下 qiniu-python-sdk 错误及解决方法</title><link>https://typonotes.com/posts/2016/11/10/windows-qiniu-python-sdk-typeerror/</link><pubDate>Thu, 10 Nov 2016 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2016/11/10/windows-qiniu-python-sdk-typeerror/</guid><description>报错信息 File &amp;#34;E:\Python27\lib\site-packages\qiniu\zone.py&amp;#34;, line 131, in host_cache_file_path return home + &amp;#34;/.qiniu_pythonsdk_hostscache.json&amp;#34; TypeError: unsupported operand type(s) for +: &amp;#39;NoneType&amp;#39; and &amp;#39;str&amp;#39; 解决方法 def host_cache_file_path(self): home = os.getenv(&amp;#34;HOME&amp;#34;) # @ 增加 None 值判断 # @ 如果 home 值为 None， 则使用当前路径 if home is None: # home=os.path.join(&amp;#39;.&amp;#39;+&amp;#39;C:\Users\Public&amp;#39;) home=os.curdir # @ 修改路径链接方式 return os.path.join(home,&amp;#34;/.qiniu_pythonsdk_hostscache.json&amp;#34;) # return home + &amp;#34;/.qiniu_pythonsdk_hostscache.json&amp;#34; 出现问题后，使用当前目录 os.curdir 的值通常为运行的 python 文件的根目录（ 如： C: , E:） 问题出现原因 zone.py 预计使用环境为 linux windows 下， python 不能</description></item><item><title>python 中使用参数选项 getopt</title><link>https://typonotes.com/posts/2016/11/09/python-getopt-usage/</link><pubDate>Wed, 09 Nov 2016 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2016/11/09/python-getopt-usage/</guid><description>python 中使用 getopt 分割参数 getopt 库是 python 内建库，以使用 getopt 库为程序指定可选参数。 1 2 3 # @python_version: python_x86 2.7.11 import getopt 指定选择项 opts 使用的长短字符 参数选择项通常有长短两种： 长短选择项本身都为字符串 短选择项的符号必须单字母，如果需要使用参数，选择项符号后需要使用 :（如 'o:'。所有短选择项构成一个字符串传递给 getopt 。 长选择</description></item><item><title>python 字符串处理</title><link>https://typonotes.com/posts/2016/11/09/python-string-handing/</link><pubDate>Wed, 09 Nov 2016 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2016/11/09/python-string-handing/</guid><description>python 字符串处理 python cookbook 第一章 1.1 每次处理一个字符串 将字符串转换为列表 使用内建 list ，将字符串转换为列表 1 theList = list(theString) 1.7 反转字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 astring=&amp;#39;i have a dream&amp;#39; # 逐个字符反转 revchars=astring[::-1] # 按空格拆分为列表并反转 revwards=astring.split() revwards.reverse() revwards=&amp;#39; &amp;#39;.join(revwards) # 使用空格链接 # 逐词反转但是改变空格, 使用正则表达式 import re revwards=re.split(r&amp;#39;(\s+)&amp;#39;,astring) # 使用正则表达式拆分保留</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on 老麦的书房</title><link>https://tangx.in/tags/golang/</link><description>Recent content in golang on 老麦的书房</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 23 Jan 2023 11:09:53 +0800</lastBuildDate><atom:link href="https://tangx.in/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>DevopsCamp 第一期作业: 《cobra - 01 实现编译与参数绑定（简单）》 解题答案</title><link>https://tangx.in/posts/2023/01/23/devopscamp-cobra01/</link><pubDate>Mon, 23 Jan 2023 11:09:53 +0800</pubDate><guid>https://tangx.in/posts/2023/01/23/devopscamp-cobra01/</guid><description>DevopsCamp 第一期作业: 《cobra - 01 实现编译与参数绑定（简单）》 解题答案 原文链接: https://tangx.in/posts/2023/01/23/devopscamp-cobra01/ 本文为 DevOpsCamp 实战训练的作业解题答案 作业: cobra - 01 实现编译与参数绑定。 DevOpsCamp作业地址: https://www.devopscamp.cc/semi-plan-202301-2/posts/homework/cobra01/ 作业要求: 使用 https://github.com/spf13/cobra 实现命令工具 命令具有以下参数 --name 姓名 --age 年龄 如果年龄为空， 默认为 20 岁。 完成交叉编译脚本， 编译其他</description></item><item><title>开发 k8s 管理平台 - k8sailor - 01. 使用 k3s 快速搭建项目环境</title><link>https://tangx.in/posts/books/k8sailor/chapter01/01-install-k3s-cluster/</link><pubDate>Tue, 10 Jan 2023 10:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/k8sailor/chapter01/01-install-k3s-cluster/</guid><description>开发 k8s 管理平台 - k8sailor - 01. 使用 k3s 快速搭建项目环境 原文地址: https://tangx.in/posts/books/k8sailor/chapter01/01-install-k3s-cluster/ 安装 k3s 安装过程参考 https://tangx.in/2021/06/07/k3s-architecture-single-server/ k3s 集群版本为 v1.21.4。 因此 k8s client-go sdk 的版本也需要安装对应版本 1 2 3 4 5 6 7 8 9 10 11 # curl -sfL http://rancher-mirror.cnrancher.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh - [INFO] Finding release for channel stable [INFO] Using v1.21.4+k3s1 as release [INFO] Downloading hash http://rancher-mirror.cnrancher.com/k3s/v1.21.4-k3s1/sha256sum-amd64.txt [INFO] Downloading binary http://rancher-mirror.cnrancher.com/k3s/v1.21.4-k3s1/k3s [INFO] Verifying binary download [INFO] Installing k3s to /usr/local/bin/k3s ... 省略 初始化环境 通过命令创建一些工作负载， 以便后</description></item><item><title>开发 k8s 管理平台 - k8sailor 02. 使用 cobra 初始化程序命令与参数</title><link>https://tangx.in/posts/books/k8sailor/chapter01/02-design-cobra-command/</link><pubDate>Tue, 10 Jan 2023 10:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/k8sailor/chapter01/02-design-cobra-command/</guid><description>开发 k8s 管理平台 - k8sailor 02. 使用 cobra 初始化程序命令与参数 原文地址: https://tangx.in/posts/books/k8sailor/chapter01/02-design-cobra-command/ tag: https://github.com/tangx/k8sailor/tree/feat/01-cobra-command 为了更加方便的管理配置文件的来源， 这里使用 cobra 进行命令行构建 效果如下 1 2 3 4 5 6 7 8 9 cd cmd/k8sailor &amp;amp;&amp;amp; go run . k8s 管理平台 Usage: k8sailor [flags] Flags: --config string k8s 配置授权文件 (default &amp;#34;./k8sconfig/config.yml&amp;#34;) -h, --help help for k8sailor 编码 变量管理 在 cmd/k8sailor/global 目录中管理 全局 变量。 其中，定义一个 CmdFlag 结构体管理所有 cobra fl</description></item><item><title>开发 k8s 管理平台 - k8sailor 03. 使用 client-go sdk 链接集群</title><link>https://tangx.in/posts/books/k8sailor/chapter01/03-connect-cluster/</link><pubDate>Tue, 10 Jan 2023 10:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/k8sailor/chapter01/03-connect-cluster/</guid><description>开发 k8s 管理平台 - k8sailor 03. 使用 client-go sdk 链接集群 原文地址: https://tangx.in/posts/books/k8sailor/chapter01/03-connect-cluster/ tag: https://github.com/tangx/k8sailor/tree/feat/02-connect-cluster 使用 sdk 链接 k3s cluster 并获取 deployment 信息 1 2 3 4 cd cmd/k8sailor &amp;amp;&amp;amp; go run . * my-nginx-1 (1 replicas) * my-nginx-2 (2 replicas) 下载 client-go sdk 之前在安装 k3s 集群的时候，版本是 v0.21.4。 因此。 这里选择 client-go sdk 的版本也是 v0.21.4 如果还有其他环境， 可以使用 go mod edit 命令锁定 client-go 的版本 1 2 3 go get k8s.io/client-go@v0.21.4 go mod edit -replace=k8s.io/client-go=k8s.io/client-go@v0.21.4 连接集群并获取</description></item><item><title>开发 k8s 管理平台 - k8sailor 04. 使用 gin 创建第一个 API 接口</title><link>https://tangx.in/posts/books/k8sailor/chapter01/04-init-httpserver/</link><pubDate>Tue, 10 Jan 2023 10:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/k8sailor/chapter01/04-init-httpserver/</guid><description>开发 k8s 管理平台 - k8sailor 04. 使用 gin 创建第一个 API 接口 原文地址: https://tangx.in/posts/books/k8sailor/chapter01/04-init-httpserver/ tag: https://github.com/tangx/k8sailor/tree/feat/04-httpserver-initial 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 cd cmd/k8sailor &amp;amp;&amp;amp; go run . httpserver 启动 web 服务器 Usage: k8sailor httpserver [flags] Flags: -h, --help help for httpserver Global Flags: --config string k8s 配置授权文件 (default &amp;#34;./k8sconfig/config.yml&amp;#34;) 2021/09/24 07:56:51 open config/local.yml: no such file or directory [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached. [GIN-debug] [WARNING] Running in &amp;#34;debug&amp;#34; mode. Switch to &amp;#34;release&amp;#34; mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode) [GIN-debug] GET /k8sailor/v0/ping --&amp;gt; github.com/tangx/k8sailor/cmd/k8sailor/apis.RootGroup.func1 (3 handlers) [GIN-debug] Listening</description></item><item><title>开发 k8s 管理平台 - k8sailor 05. RESTFul API 接口规范与请求应答约定</title><link>https://tangx.in/posts/books/k8sailor/chapter01/05-design-restful-api-and-response-data/</link><pubDate>Tue, 10 Jan 2023 10:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/k8sailor/chapter01/05-design-restful-api-and-response-data/</guid><description>开发 k8s 管理平台 - k8sailor 05. RESTFul API 接口规范与请求应答约定 原文地址: https://tangx.in/posts/books/k8sailor/chapter01/05-design-restful-api-and-response-data/ tag: https://github.com/tangx/k8sailor/tree/feat/05-design-restful-api-and-response-data 强烈建议使用 RESTful 风格来设计 API 文档。 RESTful api 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # kubectl create deployment nginx-tools --image nginx:alpine --output=yaml --dry-run=client apiVersion: apps/v1 kind: Deployment metadata: creationTimestamp: null labels: app: nginx-tools name: nginx-tools # ... 省略 # kubectl create namespace hello --dry-run=client -o yaml apiVersion: v1 kind: Namespace metadata: creationTimestamp: null name: hello # ... 省略 可以看到， k8s api 中都有一个对应的 kind 描述资源类型， 这个正好符</description></item><item><title>开发 k8s 管理平台 - k8sailor 06. 使用 api/biz/dao 分层结构管理数据请求，获取 deployment 数据</title><link>https://tangx.in/posts/books/k8sailor/chapter02/06-get-all-deployments/</link><pubDate>Tue, 10 Jan 2023 10:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/k8sailor/chapter02/06-get-all-deployments/</guid><description>开发 k8s 管理平台 - k8sailor 06. 使用 api/biz/dao 分层结构管理数据请求，获取 deployment 数据 原文地址: https://tangx.in/posts/books/k8sailor/chapter02/06-get-all-deployments/ tag: https://github.com/tangx/k8sailor/tree/feat/06-get-all-deployments client -&amp;gt; apis -&amp;gt; biz -&amp;gt; dao -&amp;gt; 将业务逻辑部分分为经典三层，想法是这样的，可能实现有错误。 apis 接入层: 只用于管理 http 请求与交互。 biz 业务层: 用于处理 api 层来的请求， 封装原始数据 dao 数据访问层: 与数据库, cluster 等交互。 存取数据。 重新调整目</description></item><item><title>《kubebuilder 从零开始实战》 - 01. 使用 kuberbuilder 初始化项目</title><link>https://tangx.in/posts/books/kubebuilder-zero-to-one/01-kubebuilder-init-project/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kubebuilder-zero-to-one/01-kubebuilder-init-project/</guid><description>使用 kuberbuilder 初始化项目 代码在: https://github.com/tangx/kubebuilder-zero-to-one 1 2 kubebuilder init --domain tangx.in kubebuilder create api --group myapp --version v1 --kind Redis 1 2 3 4 5 6 7 8 9 apiVersion: myapp.tangx.in/v1 kind: Redis metadata: name: my-op-redis spec: replicas: 1 port: 3333 1 2 3 4 5 # 安装 make install # 卸载 make uninstall 查看 crd 1 2 3 k get crd |grep tangx.in redis.myapp.tangx.in 2021-11-19T06:16:43Z</description></item><item><title>《kubebuilder 从零开始实战》 - 02. 定义对象 CRD 字段， 实现第一个 DEMO</title><link>https://tangx.in/posts/books/kubebuilder-zero-to-one/02-simplest-redis-crd/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kubebuilder-zero-to-one/02-simplest-redis-crd/</guid><description>定义对象 CRD 字段， 实现第一个 DEMO 代码在: https://github.com/tangx/kubebuilder-zero-to-one 定义 CRD Redis 对象字段 在 /api/v1/redis_types.go 中， 增加 Replicas 和 Port 字段。 1 2 3 4 5 6 7 8 9 type RedisSpec struct { // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster // Important: Run &amp;#34;make&amp;#34; to regenerate code after modifying this file // Foo is an example field of Redis. Edit redis_types.go to remove/update // Foo string `json:&amp;#34;foo,omitempty&amp;#34;` Replicas int `json:&amp;#34;replicas,omitempty&amp;#34;` Port int32 `json:&amp;#34;port,omitempty&amp;#34;` } 这个 RedisSpec 对应 /deploy/my-op-redis.yml 中的 spec 1 2 3 4 5 6 7 8 9 10 apiVersion: myapp.tangx.in/v1 kind: Redis metadata: name: my-op-redis spec: replicas: 1 port: 3333 编码 Reconcile 调谐逻辑 在 /controllers/redis_controller.go 中编码 R</description></item><item><title>《kubebuilder 从零开始实战》 - 03. 优化配置 发布 crd controller 到集群</title><link>https://tangx.in/posts/books/kubebuilder-zero-to-one/03-deploy-crd-controller/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kubebuilder-zero-to-one/03-deploy-crd-controller/</guid><description>优化配置 发布 crd controller 到集群 设置 docker server 网络代理， 避免编译的时候下载所依赖的 gcr.io 镜像失败。 参考文章 设置 docker server 网路代理 修改 Makefile, 设置默认 image name 1 2 3 4 VERSION ?= v$(shell cat .version) # Image URL to use all building/pushing image targets IMG ?= cr.docker.tangx.in/jtredis/controller:$(VERSION) 修改镜像 pull 策略。 在 /config/manager/manager.yaml 配置文件中， 添加 imagePullPolicy 策略。 由于本地开发， 并不准备上传到云上， 所以设置为 IfNotPresent。 1 2</description></item><item><title>《kubebuilder 从零开始实战》 - 04. 使用注解完整字段值约束</title><link>https://tangx.in/posts/books/kubebuilder-zero-to-one/04-filed-validation-by-comment/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kubebuilder-zero-to-one/04-filed-validation-by-comment/</guid><description>使用注解完整字段值约束 代码在: https://github.com/tangx/kubebuilder-zero-to-one 在 /api/v1/redis_types.go 中，使用注解完成字段值约束。 约束条件必须以 //+kubebuilder:validation:&amp;lt;METHOD&amp;gt;:=&amp;lt;VALUE&amp;gt; 为格式， 符号之间 没有空格。 约束条件必须 紧邻 字段， 且在字段上方。 https://book.kubebuilder.io/reference/markers/crd-validation.html 1 2 3 4 5 6 7 8 9 10 type RedisSpec struct { // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster // Important: Run &amp;#34;make&amp;#34; to regenerate code after modifying this file Replicas int `json:&amp;#34;replicas,omitempty&amp;#34;` //+kubebuilder:validation:Minimum:=1234 //+kubebuilder:validation:Maximum:=54321 Port int32 `json:&amp;#34;port,omitempty&amp;#34;` } 重新编译安装 1 make install 使用命令查看查看 1 2 3 4 5 6 7</description></item><item><title>《kubebuilder 从零开始实战》 - 05. 使用注解完整字段值约束</title><link>https://tangx.in/posts/books/kubebuilder-zero-to-one/05-filed-validation-by-webhook/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kubebuilder-zero-to-one/05-filed-validation-by-webhook/</guid><description>通过 webhook 进行字段验证 代码在: https://github.com/tangx/kubebuilder-zero-to-one 通过 kubebuilder 生成代码 1 2 3 4 5 # 创建 api kubebuilder create api --group myapp --version v1 --kind Redis # 创建 api 的 webhook kubebuilder create webhook --group myapp --version v1 --kind Redis --defaulting --programmatic-validation 增加 webhook 条件 在 /api/v1/redis_webhook.go 中增加检查条件。 检查 webhook 被触发有三个条件 Create / Update / Delete 时间节点, 分别对应三个方法。 如下是 创建时检查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func (r *Redis) ValidateCreate() error { redislog.Info(&amp;#34;validate create&amp;#34;, &amp;#34;name&amp;#34;, r.Name) // 条件判断 if</description></item><item><title>《kubebuilder 从零开始实战》 - 06. 使用 Operator 创建并发布一个 Pod</title><link>https://tangx.in/posts/books/kubebuilder-zero-to-one/06-create-pod-by-redis-operator/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kubebuilder-zero-to-one/06-create-pod-by-redis-operator/</guid><description>使用 Operator 创建并发布一个 Pod 代码在: https://github.com/tangx/kubebuilder-zero-to-one 1. 组装 k8s api 创建 pod 创建 /controllers/helper 目录， 这里面的代码实现 k8s Workloads 的创建。 具体实现就是封装 k8s workloads 的 api 对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // CreateRedis 创建 redis pod func CreateRedisPod2(ctx context.Context, client client.Client, config *appv1.Redis) error { pod := &amp;amp;corev1.Pod{} pod.Name = config.Name pod.Namespace = config.Namespace pod.Spec.Containers = []corev1.Container{ { Name: config.Name, Image: config.Spec.Image, ImagePullPolicy: corev1.PullIfNotPresent, Ports: []corev1.ContainerPort{ { ContainerPort: config.Spec.Port, }, }, }, } // ctx := context.Background() return client.Create(ctx, pod) } 补充说明一下，为什么要</description></item><item><title>《kubebuilder 从零开始实战》 - 07.1. 使用 OwnerReference 管理资源父子关系</title><link>https://tangx.in/posts/books/kubebuilder-zero-to-one/07-1-delete-pod-by-redis-OwnerReference/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kubebuilder-zero-to-one/07-1-delete-pod-by-redis-OwnerReference/</guid><description>使用 OwnerReference 管理资源父子关系 代码在: https://github.com/tangx/kubebuilder-zero-to-one https://kubernetes.io/blog/2021/05/14/using-finalizers-to-control-deletion/ 在上一章的代码可以通过如下命令创建一个 redis 实例， 并随即创建一个 Pod 1 ka -f deploy/ 但是在使用如下命令删除 redis 实例时， 虽然命令行界面提示删除成功， 但是创建的 Pod 依旧存在。 1 krm -f deploy/ 其原因是 redis 实例 与 Pod 之间 没有 建立关联关系。 那要如何创建关联关系呢？ 可以参考阅读官方博客，</description></item><item><title>《kubebuilder 从零开始实战》 - 07.2. 使用 finalizers 防止资源被删除</title><link>https://tangx.in/posts/books/kubebuilder-zero-to-one/07-2-delete-pod-by-finalizers/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kubebuilder-zero-to-one/07-2-delete-pod-by-finalizers/</guid><description>使用 finalizers 防止资源被删除 代码在: https://github.com/tangx/kubebuilder-zero-to-one 上一章使用了 OwnerReference 关联 redis instance 和所创建的 Pod， 这里的删除是通过 k8s 内置的关系处理器处理的。 https://kubernetes.io/blog/2021/05/14/using-finalizers-to-control-deletion/ 根据官方博客文档中的阐述， 当一个资源的额 finalizers 没有被清空时， 这个资源将无法被删除。 因此， 本章通过 finalizers 来建立 redis instance 和所创建 pod 的关系， 以及处理删除逻辑 1. 创建 redis instance 与 pod 的关系 在 /controllers/helper/redis_helper.go 通过</description></item><item><title>《kubebuilder 从零开始实战》 - 08. Pod 扩容与缩容</title><link>https://tangx.in/posts/books/kubebuilder-zero-to-one/08-scale-pod/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kubebuilder-zero-to-one/08-scale-pod/</guid><description>Pod 扩容与缩容 代码在: https://github.com/tangx/kubebuilder-zero-to-one 代码分支越来越多 增/删/改 都有了， 于是选择拆分为 3 个分支。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 扩容 func (r *RedisReconciler) increaseReconcile(ctx context.Context, redis *myappv1.Redis) (ctrl.Result, error) { // ... } // 缩容 func (r *RedisReconciler) decreaseReconcile(ctx context.Context, redis *myappv1.Redis) (ctrl.Result, error) { // ... } // 删除 func (r *RedisReconciler) deleteReconcile(ctx context.Context, redis *myappv1.Redis) (ctrl.Result, error) { // ... } 所谓 扩容/缩容， 在通过 finalizers 管理的时候就是 redis.spec.replicas 与 len(redis.finalizers) 的大小比较。 1 2 3 4 // 缩容 if len(redis.Finalizers) &amp;gt;</description></item><item><title>《kubebuilder 从零开始实战》 - 09. 监听 k8s 事件</title><link>https://tangx.in/posts/books/kubebuilder-zero-to-one/09-watch-k8s-event/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kubebuilder-zero-to-one/09-watch-k8s-event/</guid><description>监听 k8s 事件 代码在: https://github.com/tangx/kubebuilder-zero-to-one 之前的代码遗留了一个问题， 当手动通过命令删除 pod 时候， 不会出发 redis.Finalizers 的更新， 也不会重建被删除的 Pod， 实现效果并不好 1 kubectl delete pod pod_name 1. 监听事件 在 /controllers/redis_controller.go 中生成了对象和方法监听 k8s 的事件。 ctrl 创建的 Builder 可以通过 链式 调用方式， 监听多个 k8s 对象的事件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // SetupWithManager sets up the</description></item><item><title>《kubebuilder 从零开始实战》 - 10. 重建被删除的 Pod</title><link>https://tangx.in/posts/books/kubebuilder-zero-to-one/10-recreate-deleted-pod/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kubebuilder-zero-to-one/10-recreate-deleted-pod/</guid><description>重建被删除的 Pod 代码在: https://github.com/tangx/kubebuilder-zero-to-one 之前遗留了一个问题， 直接用命令行删除的 Pod 不能被重建。 这次就来解决它。 首先来整理之前遗留的问题故障点在哪里？ 使用命令 kubectl delete 直接删除 pod 的时候， redis.Finalizers 不会变更， 依旧包含被删除的 pod.Name。 在创建 Pod 的时候， 判断 Pod 是否存在使用的是 redis.Finalizers 提供信息， 而 没有判断 k8s 中真实的情况</description></item><item><title>《kubebuilder 从零开始实战》 - 11. 使用 controllerutil 优化代码</title><link>https://tangx.in/posts/books/kubebuilder-zero-to-one/11-official-package-optimize/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kubebuilder-zero-to-one/11-official-package-optimize/</guid><description>使用 controllerutil 优化代码 代码在: https://github.com/tangx/kubebuilder-zero-to-one 在之前的代码中， 对于 OwnerReference 和 Finalizers 操作我们自己实现了一些方法。 其实这些操作官方已经封好成包了， 开箱即用。 复制 /controllers/helper 保存为 /controllers/helper2。 前者保存手工代码， 后者保存优化代码。 https://pkg.go.dev/sigs.k8s.io/controller-runtime/pkg/controller/controllerutil Finalizers 操作 之前 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29</description></item><item><title>《kubebuilder 从零开始实战》 - 12. 增加 k8s event 事件支持</title><link>https://tangx.in/posts/books/kubebuilder-zero-to-one/12-add-event/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kubebuilder-zero-to-one/12-add-event/</guid><description>增加 event 事件支持 代码在: https://github.com/tangx/kubebuilder-zero-to-one k8s 官方 controller 都实现了 Events 消息信息， 如下 1 2 3 4 5 6 7 kubectl describe deployment k8s-operator-demo-controller-manager Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 15m deployment-controller Scaled up replica set k8s-operator-demo-controller-manager-75cc59d8ff to 1 Normal ScalingReplicaSet 14m deployment-controller Scaled down replica set k8s-operator-demo-controller-manager-b9d9f7886 to 0 我们自定义的 Operator 同样可以实现。 operator 支持 event 在 /controllers/redis_controller.go 中定义 RedisReconcile 的时候， 添加 EventRecord 字段。 1 2 3 4 5 6 7 8 // RedisReconciler reconciles a Redis object type RedisReconciler struct { client.Client Scheme *runtime.Scheme // 添加事件 EventRecord record.EventRecorder } 在 /main.go 中， 创</description></item><item><title>《kubebuilder 从零开始实战》 - 13. 添加 CRD 对象 Status 状态字段</title><link>https://tangx.in/posts/books/kubebuilder-zero-to-one/13-add-status/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kubebuilder-zero-to-one/13-add-status/</guid><description>添加 CRD 对象 Status 状态字段 代码在: https://github.com/tangx/kubebuilder-zero-to-one 添加 kd 状态字段 在 /api/v1/redis_types.go 的 RedisStatus 中添加需要展示的字段。 这里添加一个副本数量。 1 2 3 4 5 type RedisStatus struct { // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster // Important: Run &amp;#34;make&amp;#34; to regenerate code after modifying this file Replicas int `json:&amp;#34;replicas&amp;#34;` } 偷懒， 没有在创建或删除 pod 时进行精细控制。 而是使用 defer 在 Reconcile 退出的时候进行一次最终的赋值管理。 1 2 3 4 5 6 7 8 9 10 11 12 13</description></item><item><title>《kubebuilder 从零开始实战》 - 14. CRD 支持 kubectl scale 和 kubectl autoscale 命令</title><link>https://tangx.in/posts/books/kubebuilder-zero-to-one/14-kubectl-scale-autoscale-support/</link><pubDate>Mon, 09 Jan 2023 01:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kubebuilder-zero-to-one/14-kubectl-scale-autoscale-support/</guid><description>支持 kubectl scale 和 kubectl autoscale 命令 代码在: https://github.com/tangx/kubebuilder-zero-to-one 在 k8s 自定义资源中有关于 scale 和 hpa 的 subresources 字段， 只有这些字段被定义的时候才能支持 scale 和 autoscale 命令 官方定义如下 https://kubernetes.io/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource 在 kubebuilde 中， 使用 //+kubebuilder:subresource:scale 增加注解， 生成对应的配置。 注意， 未知需要在 //+kubebuilder:subresource:status 下方 1 2 3 //+kubebuilder:object:root=true //+kubebuilder:subresource:status //+kubebuilder:subresource:scale:specpath=.spec.replicas,statuspath=.status.replicas,selectorpath=.status.selector 三个关键字段: specpath: specReplicasPath 指定定制资源内与 scale.spec.replicas 对应的 JSON 路径。 此字段为 必需值 。 只可以使用 .spec 下的 JSON</description></item><item><title>从零开始写 k8s 发布工具 - 1.0. kustz 介绍和设计思想</title><link>https://tangx.in/posts/books/kustz/chapter01/01-introduce/</link><pubDate>Thu, 05 Jan 2023 13:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kustz/chapter01/01-introduce/</guid><description>从零开始写 k8s 发布工具（1） - kustz 介绍和设计思想 介绍 如果要在 Kubernets 发布一个应用， 并对外提供服务， 需要配置诸如 Dep, Ing, Svc 等 Config API。 他们之间又是通过 Label 组合选择而实现的 松耦合。 如果想要这些 Config API 之间的关系更加紧密， 我们可以自己再向上抽象， 通过自己的配置将他们整合在一起。 更重要的是， 我们可以通过这层</description></item><item><title>从零开始写 k8s 发布工具 - 2.1. 模仿 kubectl create 创建 Deployment 样例</title><link>https://tangx.in/posts/books/kustz/chapter02/01-sample-deployment/</link><pubDate>Thu, 05 Jan 2023 13:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kustz/chapter02/01-sample-deployment/</guid><description>2.1. 模仿 kubectl create 创建 Deployment 样例 为了简单， 我们假定所管理的 Deployment 都是 单容器 的。 首先参考 kubectl create 命令 1 $ kubectl create deployment my-dep --image=busybox --replicas 1 --dry-run=client -o yaml 安装 client-go API 访问 client-go https://github.com/kubernetes/client-go 1 $ go get k8s.io/client-go@v0.25.4 这里直接选用最新版本 v0.25.4。 对于其他版本的兼容， 留在以后再做。 定义 Kustz Config 参考 kubectl create 命令， 创建配置文件 kustz.yml 结构如下 1 2 3 4 5 6 7 8 # kustz.yml namespace: demo-demo name: srv-webapp-demo service: name: nginx image: docker.io/library/nginx:alpine</description></item><item><title>从零开始写 k8s 发布工具 - 2.2. 定义字符串创建 Service</title><link>https://tangx.in/posts/books/kustz/chapter02/02-define-strings-to-service/</link><pubDate>Thu, 05 Jan 2023 13:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kustz/chapter02/02-define-strings-to-service/</guid><description>2.2. 定义字符串创建 Service 大家好， 我是老麦， 一个小运维。 今天我们为 kustz 增加 service 解析功能。 通过 kubectl create service 命令可以看到， service 的模式还是挺多的。 1 2 3 4 5 6 7 8 9 10 11 $ kubectl create service -h Create a service using a specified subcommand. Aliases: service, svc Available Commands: clusterip Create a ClusterIP service externalname Create an ExternalName service loadbalancer Create a LoadBalancer service nodeport Create a NodePort service 除了以上列出来的四种之外， 还用一种 Headless Service( https://kubernetes.io/docs/concepts/services-networking/service/#headless-services )。 Headless Service 是当 类型 为 Clu</description></item><item><title>从零开始写 k8s 发布工具 - 2.3. 解析 URL 为 Ingress</title><link>https://tangx.in/posts/books/kustz/chapter02/03-parse-url-to-ingress/</link><pubDate>Thu, 05 Jan 2023 13:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kustz/chapter02/03-parse-url-to-ingress/</guid><description>2.3. 解析 URL 为 Ingress 之前已经提到过， 在 kustz.yml 中的字段值， 要尽量做到 见名知义。 对于 Ingress 而言， 在发布之后， 我们访问的就是 URL 地址。 http://api.example.com/v1 因此我们可以考虑 从结果推导解析渲染 Ingress 。 Kubernetes Ingress 老规矩， 我们还是通过命令看看创建一个 ingress 需要提供哪些参数。 1 2 $ kubectl create ingress simple --rule=&amp;#34;foo.com/bar=svc1:8080,tls=my-cert&amp;#34; -o yaml --dry-run=client 在 rule 中， 提供了两组 k-v。 其中， foo.com/bar 就是一个不带协</description></item><item><title>从零开始写 k8s 发布工具 - 2.4. 使用 kustomize 管理所有 k8s 文件</title><link>https://tangx.in/posts/books/kustz/chapter02/04-kustomize/</link><pubDate>Thu, 05 Jan 2023 13:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kustz/chapter02/04-kustomize/</guid><description>2.4. 使用 kustomize 管理所有 k8s 文件 前面已经简单的封装了 Deployment, Service, Ingress， 完成了零部件的创建。 今天就通过 Kustomization 进行组装， 实现流水线。 Kustomize 开始之前， 先来安装 kustomize 库。 1 $ go get sigs.k8s.io/kustomize/v3 这里补充一下， 访问 Github https://github.com/kubernetes-sigs/kustomize/ 。 kustomize () 首页 README.md 并没有提到 go get 的包名。 通常 k8s 的代码在 github 上都是镜像。 这时候只需要进到 go.mod ， 包名就一目了然。 1 2 3 4</description></item><item><title>从零开始写 k8s 发布工具 - 2.5. 使用 cobra 实现 kustz 命令</title><link>https://tangx.in/posts/books/kustz/chapter02/05-kustz-cli/</link><pubDate>Thu, 05 Jan 2023 13:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kustz/chapter02/05-kustz-cli/</guid><description>2.5. 使用 cobra 实现 kustz 命令 有了前面几章的努力， 我们的命令行工具 kustz 终于要问世了。 kustz 命令 当前命令功能就很简单。 default: 输出 kustz 默认配置。 render: 读取 kustz 配置并生成 kustomize 配置四件套。 1 2 3 4 5 $ kustz -h Available Commands: default 在屏幕上打印 kustz 默认配置 render 读取 kustz 配置， 生成 kustomize 所需文件 编码 本章的代码都很简单， 就是设计的文件比较多。 使用 cobra 创建命令</description></item><item><title>从零开始写 k8s 发布工具 - 3.1. 为 Container 添加环境变量</title><link>https://tangx.in/posts/books/kustz/chapter03/01-container-env-var/</link><pubDate>Thu, 05 Jan 2023 13:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kustz/chapter03/01-container-env-var/</guid><description>3.1. 为 Container 添加环境变量 再前面一章中， 我们已经完成了 Deployment, Service, Ingress 和 Kustomization API 的封装。 并通过 cobra 库创建了属于我们自己的 kustz 命令。 然而 kustz 的功能还简陋。 今天我们就先来为容器添加环境变量。 为容器设置环境变量 在官方文档中， 提高了两种为容器设置环境变量的方法 https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/ env: 提供 k-v 模式 键值对。 值可以直接 value 提供。 也可以通过 valueFrom 从 secret</description></item><item><title>从零开始写 k8s 发布工具 - 3.2. ConfigMap 和 Secret 的生成器</title><link>https://tangx.in/posts/books/kustz/chapter03/02-configmap-secret-generator/</link><pubDate>Thu, 05 Jan 2023 13:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kustz/chapter03/02-configmap-secret-generator/</guid><description>3.2. ConfigMap 和 Secret 的生成器 上一节我们通过 k-v 和 YAML文件 为容器添加环境变量。 同时也提到了可以通过 envFrom 这个关键字， 直接读取 ConfigMap 或 Secret 中的 k-v 作为容器的环境变量。 除了环境变量之外， ConfigMap 和 Secret 还能管理的东西还很多。 所以我个人觉得单应用管理部署的话， 对于配置的管理，还是比较重要的。 Kustomize 中的 ConfigMap Env File 在 kustzomize 中， ConfigMap 和 Secret 都</description></item><item><title>从零开始写 k8s 发布工具 - 3.3. 注入 ConfigMap 和 Secrets 到容器环境变量</title><link>https://tangx.in/posts/books/kustz/chapter03/03-container-env-from/</link><pubDate>Thu, 05 Jan 2023 13:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kustz/chapter03/03-container-env-from/</guid><description>3.3. 注入 ConfigMap 和 Secrets 到容器环境变量 大家好， 我是老麦。 一个运维小学生。 有了前面两张的铺垫， 今天这个很简单。 我们说说另外一种为容器注入环境变量的方式。 容器变量注入 EnvFrom 前面我们提到过， Container 有两种方式定义环境变量， 其中一种就是 envFrom， 从 ConfigMap 或 Secret 中读取所有键值对作为容器的变量。 ConfigMap 和 Secret 看起来是这样</description></item><item><title>从零开始写 k8s 发布工具 - 3.4. 用字符串定义容器申请资源上下限</title><link>https://tangx.in/posts/books/kustz/chapter03/04-container-resources/</link><pubDate>Thu, 05 Jan 2023 13:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kustz/chapter03/04-container-resources/</guid><description>3.4. 用字符串定义容器申请资源上下限 Pod 的资源申请， 在调度策略中， 是一个重要的参数数据。 因此其重要性自然不必多说 容器资源申请 在官网中， 对于资源的申请和管理有详细的描述。 https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/ 和 服务质量 QoS 息息相关， https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/quality-service-pod/ 这里简单的归类， 可以速记， 按照服务质量高到低 Guaranteed: request = limit Burstable: request &amp;lt; limit BestEffort: 没有 request 和 limit kustz.yml 配置 还是先来看看 kustz.yml</description></item><item><title>从零开始写 k8s 发布工具 - 3.5. 为 Container 添加健康检查方法</title><link>https://tangx.in/posts/books/kustz/chapter03/05-container-probe/</link><pubDate>Thu, 05 Jan 2023 13:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kustz/chapter03/05-container-probe/</guid><description>3.5. 为 Container 添加健康检查方法 kustz 终于到了准生产的地步了。 今天的健康检查接口， 就为我们解决这个问题。 我们要知道， 确定一个应用能不能对外提供服务之前， 需要进行一个 可用性 检测。 而这个检测通常被我们称为 健康检查。 Kubernetes 的健康检查 在 Kubernetes 中， 为我们提供了 主要 的 3类状态 的健康检查。 startup: 等待探针。 如果执行成功，</description></item><item><title>从零开始写 k8s 发布工具 - 3.6. 镜像拉取鉴权和策略</title><link>https://tangx.in/posts/books/kustz/chapter03/06-image-pull-policy/</link><pubDate>Thu, 05 Jan 2023 13:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kustz/chapter03/06-image-pull-policy/</guid><description>3.6. 镜像拉取鉴权和策略 今天我们解决镜像拉取鉴权和策略 镜像拉取鉴权 拉取私有镜像或私有仓库镜像的时候， 需要提供鉴权信息。 在 Kubernets 中， 通过 Secret 管理账号这些账号信息。 Secret 类型分为两种， kubernetes.io/dockerconfigjson: 如果有linux安装了 docker， 就是 ~/.docker/config.json 这个文件。 kubernetes.io/dockercfg: 不太熟。 在 /pkg/tokube/pod.go 中， 可以看到 ImagePullSecrets 的处理方法。 就是将字符串转为 kubernetes 的</description></item><item><title>从零开始写 k8s 发布工具 - 4.1. 使用 cobrautils 为命令添加更实用的命令参数</title><link>https://tangx.in/posts/books/kustz/chapter04/01-kustz-flags/</link><pubDate>Thu, 05 Jan 2023 13:28:03 +0800</pubDate><guid>https://tangx.in/posts/books/kustz/chapter04/01-kustz-flags/</guid><description>4.1. 使用 cobrautils 为命令添加更实用的命令参数 之前的章节， 我们陆陆续续给 kustz 库添加了很多丰富服务的配置 但 kustz 命令， 还是处于一个很原始的命令状态。 接下来我们给 kustz 添加一些更丰富的参数 ， 使 kustz 用起来更顺手。 在 CICD 的中， 一般情况下 变量，健康检查， 镜像策略 等很难发生变动。 而镜像名称 经常性 的在每次打包后发生变化</description></item><item><title>golang deepcopy 的两种实现方式</title><link>https://tangx.in/posts/2021/12/14/golang-struct-interface-deepcopy/</link><pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/12/14/golang-struct-interface-deepcopy/</guid><description>golang deepcopy 的两种实现方式 最近在基于 gin 封装 rum-gonic - github web 框架的过程中，遇到了一个问题。 在注册路由的时候传递是 指针对象， 因此造成所有的 request 请求使用相同的 CreateUser 对象, 出现并发冲突。 1 2 3 4 5 6 7 8 9 func init() { RouterGroup_User.Register(&amp;amp;CreateUser{}) } type CreateUser struct { httpx.MethodPost `path:&amp;#34;&amp;#34;` Name string `query:&amp;#34;name&amp;#34;` Password string `query:&amp;#34;password&amp;#34;` } struct 结构体 deepcopy 的实现 基于 sturct 的实现， 由于有 明确 的 struct 对象结构， 通常直接创建一个</description></item><item><title>配置文件初始化思路一二三</title><link>https://tangx.in/posts/2021/11/26/golang-project-config-initial-tips/</link><pubDate>Fri, 26 Nov 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/11/26/golang-project-config-initial-tips/</guid><description>配置文件初始化思路要点一二三 配置文件字段如下 1 2 3 4 type Config struct { Server Server `json:&amp;#34;server,omitempty&amp;#34; yaml:&amp;#34;server,omitempty&amp;#34;` Ingresses netv1.IngressSpec `json:&amp;#34;ingresses,omitempty&amp;#34; yaml:&amp;#34;ingresses,omitempty&amp;#34;` } 完整配置如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 server: port: 8080 ingresses: rules: - host: www.baidu.com http: paths: - backend: service: name: /search port: number: 80 pathType: ImplementationSpecific # pathType: Exact # pathType: Prefix Config 文件 读取多个文件后合并最终结果。 可以将不同的功能配置放在不同的文件中， 在数据内容多的情况下更有利于操作。</description></item><item><title>gin 内部重定向时 middleware 不可用异常</title><link>https://tangx.in/posts/2021/09/27/gin-301-redirect-slash-cause-cors-error/</link><pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/27/gin-301-redirect-slash-cause-cors-error/</guid><description>gin 内部重定向时 middleware 不可用异常 axios 请求时出现 cors error 在使用 axios 请求后端时，遇到 cors 跨域问题， 虽然已经在 gin 中添加了 cors 的 middleware 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func cors() gin.HandlerFunc { return func(c *gin.Context) { method := c.Request.Method origin := &amp;#34;*&amp;#34; if method != &amp;#34;&amp;#34; { c.Header(&amp;#34;Access-Control-Allow-Origin&amp;#34;, origin) // 可将将 * 替换为指定的域名 c.Header(&amp;#34;Access-Control-Allow-Methods&amp;#34;, &amp;#34;POST, GET, OPTIONS, PUT, DELETE, UPDATE&amp;#34;) c.Header(&amp;#34;Access-Control-Allow-Headers&amp;#34;, &amp;#34;Origin, X-Requested-With, Content-Type, Accept, Authorization,X-Token&amp;#34;) c.Header(&amp;#34;Access-Control-Expose-Headers&amp;#34;, &amp;#34;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Cache-Control, Content-Language, Content-Type&amp;#34;) c.Header(&amp;#34;Access-Control-Allow-Credentials&amp;#34;, &amp;#34;true&amp;#34;) } if method == &amp;#34;OPTIONS&amp;#34; { c.AbortWithStatus(http.StatusNoContent) } } } 问题原因 gin Middleware</description></item><item><title>golang 反射</title><link>https://tangx.in/posts/2021/09/22/golang-reflect/</link><pubDate>Wed, 22 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/22/golang-reflect/</guid><description>golang 反射 golang 反射很好用， 也有很多坑。 代码在: https://github.com/tangx-labs/golang-reflect-demo Kind 和 Type 在 golang 的反射中， 有两个可以表示 类型 的关键字， Kind 和 Type 。 定义覆盖范围 Kind 的定义覆盖范围必 Type 要大。 Kind 在定义上要 更抽象， Type 要更具体。 可以简单理解为， 如果 Kind 是 车 ， 那么 Type 可能是 公交车 、 消防车 内置类型字面值 https://github.com/tangx-labs/golang-reflect-demo/blob/master/kind_type_test.go#L10 虽然 Kind 的定义比 Type 要大， 但是在 内置 类型的时候</description></item><item><title>在 golang 中 slice[a :b :c] 是什么意思? golang slice 完整表达式</title><link>https://tangx.in/posts/2021/09/22/golang-slice-expressions/</link><pubDate>Wed, 22 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/22/golang-slice-expressions/</guid><description>golang slice 表达式 https://golang.org/ref/spec#Slice_expressions 通常，我们写的 golang slice 边界只有两个数字 slice[1:3] ， 这是一种简单写法。 而完整写法是 三个数字 slice[1:3:5] 简单表达式 一个冒号， 两个参数， 表示 slice 元素的 起止区间 1 a[low:high] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( &amp;#34;fmt&amp;#34; ) func main() { a := [5]int{1, 2, 3, 4, 5} s := a[1:4] // [2,3,4] fmt.Println(s) s1 := a[2:] // 等价于 a[2 : len(a) s2 := a[:3] // 等价于 a[0 : 3] s3 := a[:] // 等价于</description></item><item><title>golang 使用反射绑定 cobra flag 参数</title><link>https://tangx.in/posts/2021/09/18/golang-cobra-flag-binder/</link><pubDate>Sat, 18 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/18/golang-cobra-flag-binder/</guid><description>golang 使用反射绑定 cobra flag 参数 cobra https://github.com/spf13/cobra 是 golang 中一个非常好用的 命令 开发库。 但是绑定 flag 参数的时候略微有点繁琐， 不但有多少个参数就需要写多少行绑定代码， 而且参数定义和描述也是分开的， 非常的不直观。 1 2 3 4 5 6 func init() { rootCmd.Flags().StringVarP(&amp;amp;stu.Name, &amp;#34;name&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;zhangsanfeng&amp;#34;, &amp;#34;student name&amp;#34;) rootCmd.Flags().Int64VarP(&amp;amp;stu.Age, &amp;#34;age&amp;#34;, &amp;#34;a&amp;#34;, 18, &amp;#34;student age&amp;#34;) // ... } 想着吧， 反正都要了解 golang reflect 反射, 不如就用 反射 实现一个绑定支</description></item><item><title>go-jarvis 容器化 go 应用开发配置管理利器</title><link>https://tangx.in/posts/2021/09/17/go-jarvis-config-manager/</link><pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/17/go-jarvis-config-manager/</guid><description>go-jarvis/jarivs 为了方便 golang 容器化开发的时候管理配置。 核心功能 根据 config 结构体生成 yaml 配置文件 程序启动时， 从 yaml 配置文件和 环境变量 中对 config 赋值 执行逻辑 根据配置 config{} 生成对应的 default.yml 配置文件。 读取依次配置文件 default.yml, config.yml + 分支配置文件.yml + 环境变量 根据 GitlabCI, 分支配置文件 config.xxxx.yml 如没有 CI, 读取本地文件: local.yml 使用需求 config 对象中的结构体中，</description></item><item><title>GET 请求也能传递 JSON Body</title><link>https://tangx.in/posts/2021/09/09/ginbinder-allow-get-accept-body-data/</link><pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/09/ginbinder-allow-get-accept-body-data/</guid><description>GET 请求也能传递 Body 数据 通常而言， GET 请求很少传递 Body 数据， 大多情况下都是放在 url 中， 例如 1 http://example.com/api?key1=value1&amp;amp;key2=value2 但是这样做， 可能由于 传递数据过多 导致 URL 过程而被拦截。 运营商会缓存 URL 地址以达到加速的效果， 而有些参数又不想被缓存。 等等 虽然， 可以使用 POST 请求代替 GET 请求， 在 Body 中传递数据， 但是这样做可能会破坏 RESTful 风格的 API 格</description></item><item><title>golang 括号用法总结</title><link>https://tangx.in/posts/2021/09/09/golang-brackets/</link><pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/09/golang-brackets/</guid><description>golang 括号用法总结 1 2 3 4 5 6 7 8 var ( f unsafe.Pointer a io.ReadCloser = (*os.File)(f) // 只要是一个指针就可以 b io.Reader = a // a的方法集大于等于b，就可以做隐式的转换！ c io.Closer = a // 同样 d io.Reader = c.(io.Reader) // 显式转换，c这个接口很明显方法集和io.Reader不同 // 但是万一传入c的对象拥有io.Reader接口呢？比如 ) 提问， 以上这些括号都是</description></item><item><title>如果 golang map 值不能修改怎么办？</title><link>https://tangx.in/posts/2021/09/07/golang-map-struct-value-modify/</link><pubDate>Tue, 07 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/07/golang-map-struct-value-modify/</guid><description>值对象与指针对象 假设有一个 map 对象 map[string]Person ， 其中 Person 定义如下。 是一个 struct 1 2 3 type Person struct { Age int } 现在有一个需求， map 中的 Person 对象年龄为 0 ， 则将其默认值设置为 18。 很显然， 由于 map[string]Person 中保存的是 值对象 ，因此通过任意方式获取的都是 值对象的副本 ， 所有修改都是在副本上， 不能 修改真实值。 如果是 map[string]*Person 就很方便了。 *Person 是 指针</description></item><item><title>golang 中的环境变量操作</title><link>https://tangx.in/posts/2021/09/06/golang-os-env-operation/</link><pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/06/golang-os-env-operation/</guid><description>golang 中的环境变量操作 golang 中的环境变量操作都在 os 包下面， 只有很少的几个， 而且字面意思也很明确。 所有环境变量操作对象都是 字符串 (string)， 因此对于 int， bool 类型需要自己实现转换。 golang 程序执行的时候， 是在 linux 系统中 fork 的一种子进程中 golang程序 在 复制了 fork 时 （开始运行的那一瞬间）的所有变</description></item><item><title>一道 golang 切片面试题</title><link>https://tangx.in/posts/2021/08/30/golang-array-and-slice/</link><pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/08/30/golang-array-and-slice/</guid><description>一道 golang 切片面试题 为什么 sl[:5] 会返回底层数组的数据呢？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import &amp;#34;fmt&amp;#34; func main() { sl := make([]int, 0, 10) appendFn := func(s []int) { // 值传递， s 并不是 sl。 // 但数组是引用类型， 所以可以修改底层数组 fmt.Println(&amp;#34;s ptr(old):&amp;#34;, s) // [] s = append(s, 10, 20, 30) fmt.Println(&amp;#34;s ptr(new):&amp;#34;, s) // [10,20,30] } fmt.Println(sl) // [] appendFn(sl) fmt.Println(sl) // [] // 这里有点坑， 并不是取的 sl ，而是底</description></item><item><title>golang 下划线完成对象的接口类型检查</title><link>https://tangx.in/posts/2021/08/26/golang-varible-decleare-with-blank-identifier/</link><pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/08/26/golang-varible-decleare-with-blank-identifier/</guid><description>golang 下划线完成对象的接口类型检查 在 Gin 源码中 有一行代码如下 1 var _ IRouter = &amp;amp;RouterGroup{} 乍一看， 是一个 赋值 操作， 但是前面又使用了 空白描述符(下划线) 。 这是什么意思呢？ 答案是： 接口类型检查 在 《Effective GO》 Interface Check 中的描述有相关描述。 全文如下。 One place this situation arises is when it is necessary to guarantee within the package implementing the type that it actually satisfies the interface. If a type-for</description></item><item><title>golang 中的时间处理</title><link>https://tangx.in/posts/2021/08/23/golang-time-operation/</link><pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/08/23/golang-time-operation/</guid><description>golang 中的时间处理 在 golang 中有一个很重要的 格式化时间的字符串 2006-01-02T15:04:05Z07:00 ， 这个也是 golang 默认时间模版模版中的 time.RFC3339 1 RFC3339 = &amp;#34;2006-01-02T15:04:05Z07:00&amp;#34; golang 中关于时间的处理， 用到了上面的 每一个 数字和字母。 需要特别注意的是， 时区用的是 7 而非 6 ， 因为 6 已经在 年（2006） 中出现了 创建时间对象 time.Time 1 2 3 4 5 6 7 8 9 10 // 1. 创建当前时间对象 now := time.Now() //</description></item><item><title>ginbinder 的书写过程-一起来看gin源码吧</title><link>https://tangx.in/posts/2021/08/20/ginbinder-how-to-develop/</link><pubDate>Fri, 20 Aug 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/08/20/ginbinder-how-to-develop/</guid><description>ginbind 的实现过程-一起来看gin源码吧 是的，没错。 如果你用过 gin 那么你一定知道，gin 中绑定参数的方式很零散。 c *gon.Context 给你提供了很多中方法， 例如BindHeader, BindURI 等等， 但是如果想要绑定 reqeust 中不同地方的参数， 那对不起咯，并没有。 另外， gin 中的 Bind 接口， 默认是包含了 参数验证 validate 功能的， 因此如果你</description></item><item><title>ginbinder 一次绑定所有 request 参数</title><link>https://tangx.in/posts/2021/08/19/ginbinder/</link><pubDate>Thu, 19 Aug 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/08/19/ginbinder/</guid><description>ginbinder 一次绑定 Request 中所有需要的数据 Usage 废弃/不可用: 弃用原生 tag form tag。 保持: 使用 tag uri 绑定路径中的参数。 作用于某个字段 就是 example.com/:some/:path 中 冒号后面的 保持: 使用 tag header 绑定 header。 作用于某个字段 新增: 新增 tag query tag 绑定通过 Query 传递的参数。 作用于某个字段 就是 example.com/some/path?a=1&amp;amp;b=2 中 问号后面的那一串 新增: 新增 tag cookie 绑定 cookie 中 简单 的键</description></item><item><title>go1.17泛型尝鲜</title><link>https://tangx.in/posts/2021/08/18/go117-generic-preview/</link><pubDate>Wed, 18 Aug 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/08/18/go117-generic-preview/</guid><description>go1.17 泛型尝鲜 语法格式如下， 需要使用 [T Ttype] 指定约束条件， 例如 [T any] 不做任何约束, [T MyInterface] 满足 MyInterface 的约束 接下来我们将尝试上述提到的内容。 1 2 3 func fname[T Ttype](args []T) T { // statement } 需要注意的是， 现在泛型在 go1.17 中依旧不是正式支持， 所以在 IDE 或者编辑器上会有报错。 编译需要指定额外的 -gcflags=-G=3 参数 1 go run -gcflags=-G=3 main.go 开始吧 不约束 any 首先，我们来</description></item><item><title>golang gin 使用 context 实现 ioc</title><link>https://tangx.in/posts/2021/07/28/ioc-by-gin-context/</link><pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/07/28/ioc-by-gin-context/</guid><description>golang gin 使用 context 实现 ioc gin 是一个流行的 golang webserver 的框架。 https://github.com/gin-gonic/gin gin 中 HandlerFunc (type HandlerFunc func(*Context)) 的使用随处可见, ex. Middleware , Handler 中。 1 2 3 4 router.GET(&amp;#34;/user/:name&amp;#34;, func(c *gin.Context) { name := c.Param(&amp;#34;name&amp;#34;) c.String(http.StatusOK, &amp;#34;Hello %s&amp;#34;, name) }) 因此，根据之前 golang context 实现 IoC 容器经验， 使用 *gin.Context 作为 IoC 容器再好不过了。 标准库 context.Context 是一个接口(interface)， gin.Context 是 gin 工程自己封装的的一个 struct， 并实现了该接口。 虽然</description></item><item><title>golang 使用 Context 实现 IoC 容器</title><link>https://tangx.in/posts/2021/07/27/ioc-by-golang-context/</link><pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/07/27/ioc-by-golang-context/</guid><description>golang 使用 Context 实现 IoC 容器 参考文章 控制反转（IoC）与依赖注入（DI） 指出了依赖注入可以降低程序的耦合性。 能更好的拆分功能与基础设施。 那么在 golang 中又怎么实现呢？ 代码地址 golang-context-ioc.go 实现了一个 MysqlDriver 实现我们所有的数据存取操作。 并在全局域中实例化了一个对象 my。 在 main.go 中创建了一个 ctx := context.Background() 使用使用 ctx 作为 IoC 容器， 使</description></item><item><title>Golang Block 到底是什么？ 怎么就能解决闭包变量冲突了？</title><link>https://tangx.in/posts/2021/06/22/golang-block/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/06/22/golang-block/</guid><description>Golang Block 到底是什么？ 怎么就能解决闭包变量冲突了？ 什么？ 你告诉我 i:=i 不仅合法，而且还常用。甚至能解决并发编程中的变量冲突？ 以下这段代码出自 golang 官方 的 Effective GO 并发编程章节。 为了解决 goroute 中变量 req 冲突， 使用了语句 req := req https://golang.org/doc/effective_go#concurrency 1 2 3 4 5 6 7 8 9 10 func Serve(queue chan *Request) { for req := range queue { req := req // Create new instance of req for the goroutine. sem &amp;lt;- 1 go func() { process(req) &amp;lt;-sem</description></item><item><title>Golang知识点(defer): 面试经常变量在 defer 中的值， 其实在问变量的作用域</title><link>https://tangx.in/posts/2021/06/21/golang-defer-func-variables-scope/</link><pubDate>Mon, 21 Jun 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/06/21/golang-defer-func-variables-scope/</guid><description>变量在 defer 中的值， 其实在问变量的作用域 有没有想过， 面试中经常问的 变量在 defer 之后的值， 其实是在问 函数变量的作用域 简单的说， defer 就是将当前操作放入 堆 中， 等待触发 return 的时候再拿出来执行。 符合堆的特色， 先进后出。 从细节来了， 还需要注意 变量 在 defer 中的 作用域 ？ 函数 的 执行操作 是在 入堆前还是后 ？ defer 中的函数</description></item><item><title>golang 为 struct 自动添加 tags</title><link>https://tangx.in/posts/2020/12/11/tips-auto-add-tags/</link><pubDate>Fri, 11 Dec 2020 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2020/12/11/tips-auto-add-tags/</guid><description>golang 为 struct 自动添加 tags vscode 中的 go 0.12.0 版本新加入了一个 auto add tags 的功能。 setting.json 配置如下 1 2 3 4 5 6 &amp;#34;go.addTags&amp;#34;: { &amp;#34;tags&amp;#34;: &amp;#34;yaml,json&amp;#34;, &amp;#34;options&amp;#34;: &amp;#34;yaml=omitempty,yaml=options2,yaml=options3,json=omitempty&amp;#34;, &amp;#34;promptForTags&amp;#34;: false, &amp;#34;transform&amp;#34;: &amp;#34;snakecase&amp;#34; }, 在 example.go 中创建一个 struct 1 2 3 4 5 type Person struct { Name string Age int Gender string } 将光标移动到 struct 结构体中， 使用 command + shift + p 选择 go: add tag for struct 即可 result 1 2 3 4 5 type Person struct { Name string `yaml:&amp;#34;name,omitempty,options2,options3&amp;#34; json:&amp;#34;name,omitempty&amp;#34;` Age int `yaml:&amp;#34;age,omitempty,options2,options3&amp;#34; json:&amp;#34;age,omitempty&amp;#34;` Gender string `yaml:&amp;#34;gender,omitempty,options2,options3&amp;#34; json:&amp;#34;gender,omitempty&amp;#34;` }</description></item><item><title>golang-use-regex-group</title><link>https://tangx.in/posts/2019/03/21/golang-use-regex-group/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2019/03/21/golang-use-regex-group/</guid><description>golang 使用 regex group 的值 与常用的语言正则不同， golang 使用 $1 表示 regex group。 而类似 sed, python 中常用的是 \1 golang playgroud 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;regexp&amp;#34; ) func main() { re := regexp.MustCompile(`([A-Z])`) s := re.ReplaceAllString(&amp;#34;UserCreate&amp;#34;, &amp;#34;.$1&amp;#34;) fmt.Println(s) // .User.Create } func Test_Regexp(t *testing.T) { chars := `(&amp;#39;|&amp;#34;)` str := `&amp;#34;123&amp;#39;abc&amp;#39;456&amp;#34;` re := regexp.MustCompile(chars) s := re.ReplaceAllString(str, `\$1`) // 这里可以使用 ` 反引号 fmt.Println(s) // \&amp;#34;123\&amp;#39;abc\&amp;#39;456\&amp;#34; } // https://stackoverflow.com/questions/43586091/how-golang-replace-string-by-regex-group python 1 2 3 import re name = re.sub(r&amp;#39;([A-Z])&amp;#39;, r&amp;#39;.\1&amp;#39;, &amp;#34;UserCreate&amp;#34;) print(name) # .User.Create</description></item></channel></rss>
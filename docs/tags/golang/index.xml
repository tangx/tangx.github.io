<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on 老麦的书房</title><link>https://tangx.in/tags/golang/</link><description>Recent content in golang on 老麦的书房</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 28 Dec 2022 13:28:03 +0800</lastBuildDate><atom:link href="https://tangx.in/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>从零开始写 k8s 发布工具（1） - kustz 介绍和设计思想</title><link>https://tangx.in/posts/2022/12/28/kustz-1-1-introduce/</link><pubDate>Wed, 28 Dec 2022 13:28:03 +0800</pubDate><guid>https://tangx.in/posts/2022/12/28/kustz-1-1-introduce/</guid><description>大家好， 我是老麦 欢迎 关注公众号 Go与云原生 或 订阅网站 https://tangx.in/ 第一时间看后续精彩文章。 觉得好的话，请猛击文章右下角「在看」 一键三连， 是对我的最大支持。 原文链接: https://tangx.in/posts/2022/12/28/kustz-1-1-introduce/ 介绍 如果要在 Kubernets 发布一个应用， 并对外提供服务， 需要配置诸如 Dep, Ing, Svc 等 Config API。 他们之间又是通过 Label 组合选择而实现的 松耦合。 如果想要这</description></item><item><title>golang deepcopy 的两种实现方式</title><link>https://tangx.in/posts/2021/12/14/golang-struct-interface-deepcopy/</link><pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/12/14/golang-struct-interface-deepcopy/</guid><description>golang deepcopy 的两种实现方式 最近在基于 gin 封装 rum-gonic - github web 框架的过程中，遇到了一个问题。 在注册路由的时候传递是 指针对象， 因此造成所有的 request 请求使用相同的 CreateUser 对象, 出现并发冲突。 1 2 3 4 5 6 7 8 9 func init() { RouterGroup_User.Register(&amp;amp;CreateUser{}) } type CreateUser struct { httpx.MethodPost `path:&amp;#34;&amp;#34;` Name string `query:&amp;#34;name&amp;#34;` Password string `query:&amp;#34;password&amp;#34;` } struct 结构体 deepcopy 的实现 基于 sturct 的实现， 由于有 明确 的 struct 对象结构， 通常直接创建一个</description></item><item><title>配置文件初始化思路一二三</title><link>https://tangx.in/posts/2021/11/26/golang-project-config-initial-tips/</link><pubDate>Fri, 26 Nov 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/11/26/golang-project-config-initial-tips/</guid><description>配置文件初始化思路要点一二三 配置文件字段如下 1 2 3 4 type Config struct { Server Server `json:&amp;#34;server,omitempty&amp;#34; yaml:&amp;#34;server,omitempty&amp;#34;` Ingresses netv1.IngressSpec `json:&amp;#34;ingresses,omitempty&amp;#34; yaml:&amp;#34;ingresses,omitempty&amp;#34;` } 完整配置如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 server: port: 8080 ingresses: rules: - host: www.baidu.com http: paths: - backend: service: name: /search port: number: 80 pathType: ImplementationSpecific # pathType: Exact # pathType: Prefix Config 文件 读取多个文件后合并最终结果。 可以将不同的功能配置放在不同的文件中， 在数据内容多的情况下更有利于操作。</description></item><item><title>gin 内部重定向时 middleware 不可用异常</title><link>https://tangx.in/posts/2021/09/27/gin-301-redirect-slash-cause-cors-error/</link><pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/27/gin-301-redirect-slash-cause-cors-error/</guid><description>gin 内部重定向时 middleware 不可用异常 axios 请求时出现 cors error 在使用 axios 请求后端时，遇到 cors 跨域问题， 虽然已经在 gin 中添加了 cors 的 middleware 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func cors() gin.HandlerFunc { return func(c *gin.Context) { method := c.Request.Method origin := &amp;#34;*&amp;#34; if method != &amp;#34;&amp;#34; { c.Header(&amp;#34;Access-Control-Allow-Origin&amp;#34;, origin) // 可将将 * 替换为指定的域名 c.Header(&amp;#34;Access-Control-Allow-Methods&amp;#34;, &amp;#34;POST, GET, OPTIONS, PUT, DELETE, UPDATE&amp;#34;) c.Header(&amp;#34;Access-Control-Allow-Headers&amp;#34;, &amp;#34;Origin, X-Requested-With, Content-Type, Accept, Authorization,X-Token&amp;#34;) c.Header(&amp;#34;Access-Control-Expose-Headers&amp;#34;, &amp;#34;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Cache-Control, Content-Language, Content-Type&amp;#34;) c.Header(&amp;#34;Access-Control-Allow-Credentials&amp;#34;, &amp;#34;true&amp;#34;) } if method == &amp;#34;OPTIONS&amp;#34; { c.AbortWithStatus(http.StatusNoContent) } } } 问题原因 gin Middleware</description></item><item><title>golang 反射</title><link>https://tangx.in/posts/2021/09/22/golang-reflect/</link><pubDate>Wed, 22 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/22/golang-reflect/</guid><description>golang 反射 golang 反射很好用， 也有很多坑。 代码在: https://github.com/tangx-labs/golang-reflect-demo Kind 和 Type 在 golang 的反射中， 有两个可以表示 类型 的关键字， Kind 和 Type 。 定义覆盖范围 Kind 的定义覆盖范围必 Type 要大。 Kind 在定义上要 更抽象， Type 要更具体。 可以简单理解为， 如果 Kind 是 车 ， 那么 Type 可能是 公交车 、 消防车 内置类型字面值 https://github.com/tangx-labs/golang-reflect-demo/blob/master/kind_type_test.go#L10 虽然 Kind 的定义比 Type 要大， 但是在 内置 类型的时候</description></item><item><title>在 golang 中 slice[a :b :c] 是什么意思? golang slice 完整表达式</title><link>https://tangx.in/posts/2021/09/22/golang-slice-expressions/</link><pubDate>Wed, 22 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/22/golang-slice-expressions/</guid><description>golang slice 表达式 https://golang.org/ref/spec#Slice_expressions 通常，我们写的 golang slice 边界只有两个数字 slice[1:3] ， 这是一种简单写法。 而完整写法是 三个数字 slice[1:3:5] 简单表达式 一个冒号， 两个参数， 表示 slice 元素的 起止区间 1 a[low:high] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( &amp;#34;fmt&amp;#34; ) func main() { a := [5]int{1, 2, 3, 4, 5} s := a[1:4] // [2,3,4] fmt.Println(s) s1 := a[2:] // 等价于 a[2 : len(a) s2 := a[:3] // 等价于 a[0 : 3] s3 := a[:] // 等价于</description></item><item><title>golang 使用反射绑定 cobra flag 参数</title><link>https://tangx.in/posts/2021/09/18/golang-cobra-flag-binder/</link><pubDate>Sat, 18 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/18/golang-cobra-flag-binder/</guid><description>golang 使用反射绑定 cobra flag 参数 cobra https://github.com/spf13/cobra 是 golang 中一个非常好用的 命令 开发库。 但是绑定 flag 参数的时候略微有点繁琐， 不但有多少个参数就需要写多少行绑定代码， 而且参数定义和描述也是分开的， 非常的不直观。 1 2 3 4 5 6 func init() { rootCmd.Flags().StringVarP(&amp;amp;stu.Name, &amp;#34;name&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;zhangsanfeng&amp;#34;, &amp;#34;student name&amp;#34;) rootCmd.Flags().Int64VarP(&amp;amp;stu.Age, &amp;#34;age&amp;#34;, &amp;#34;a&amp;#34;, 18, &amp;#34;student age&amp;#34;) // ... } 想着吧， 反正都要了解 golang reflect 反射, 不如就用 反射 实现一个绑定支</description></item><item><title>go-jarvis 容器化 go 应用开发配置管理利器</title><link>https://tangx.in/posts/2021/09/17/go-jarvis-config-manager/</link><pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/17/go-jarvis-config-manager/</guid><description>go-jarvis/jarivs 为了方便 golang 容器化开发的时候管理配置。 核心功能 根据 config 结构体生成 yaml 配置文件 程序启动时， 从 yaml 配置文件和 环境变量 中对 config 赋值 执行逻辑 根据配置 config{} 生成对应的 default.yml 配置文件。 读取依次配置文件 default.yml, config.yml + 分支配置文件.yml + 环境变量 根据 GitlabCI, 分支配置文件 config.xxxx.yml 如没有 CI, 读取本地文件: local.yml 使用需求 config 对象中的结构体中，</description></item><item><title>GET 请求也能传递 JSON Body</title><link>https://tangx.in/posts/2021/09/09/ginbinder-allow-get-accept-body-data/</link><pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/09/ginbinder-allow-get-accept-body-data/</guid><description>GET 请求也能传递 Body 数据 通常而言， GET 请求很少传递 Body 数据， 大多情况下都是放在 url 中， 例如 1 http://example.com/api?key1=value1&amp;amp;key2=value2 但是这样做， 可能由于 传递数据过多 导致 URL 过程而被拦截。 运营商会缓存 URL 地址以达到加速的效果， 而有些参数又不想被缓存。 等等 虽然， 可以使用 POST 请求代替 GET 请求， 在 Body 中传递数据， 但是这样做可能会破坏 RESTful 风格的 API 格</description></item><item><title>golang 括号用法总结</title><link>https://tangx.in/posts/2021/09/09/golang-brackets/</link><pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/09/golang-brackets/</guid><description>golang 括号用法总结 1 2 3 4 5 6 7 8 var ( f unsafe.Pointer a io.ReadCloser = (*os.File)(f) // 只要是一个指针就可以 b io.Reader = a // a的方法集大于等于b，就可以做隐式的转换！ c io.Closer = a // 同样 d io.Reader = c.(io.Reader) // 显式转换，c这个接口很明显方法集和io.Reader不同 // 但是万一传入c的对象拥有io.Reader接口呢？比如 ) 提问， 以上这些括号都是</description></item><item><title>如果 golang map 值不能修改怎么办？</title><link>https://tangx.in/posts/2021/09/07/golang-map-struct-value-modify/</link><pubDate>Tue, 07 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/07/golang-map-struct-value-modify/</guid><description>值对象与指针对象 假设有一个 map 对象 map[string]Person ， 其中 Person 定义如下。 是一个 struct 1 2 3 type Person struct { Age int } 现在有一个需求， map 中的 Person 对象年龄为 0 ， 则将其默认值设置为 18。 很显然， 由于 map[string]Person 中保存的是 值对象 ，因此通过任意方式获取的都是 值对象的副本 ， 所有修改都是在副本上， 不能 修改真实值。 如果是 map[string]*Person 就很方便了。 *Person 是 指针</description></item><item><title>golang 中的环境变量操作</title><link>https://tangx.in/posts/2021/09/06/golang-os-env-operation/</link><pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/09/06/golang-os-env-operation/</guid><description>golang 中的环境变量操作 golang 中的环境变量操作都在 os 包下面， 只有很少的几个， 而且字面意思也很明确。 所有环境变量操作对象都是 字符串 (string)， 因此对于 int， bool 类型需要自己实现转换。 golang 程序执行的时候， 是在 linux 系统中 fork 的一种子进程中 golang程序 在 复制了 fork 时 （开始运行的那一瞬间）的所有变</description></item><item><title>一道 golang 切片面试题</title><link>https://tangx.in/posts/2021/08/30/golang-array-and-slice/</link><pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/08/30/golang-array-and-slice/</guid><description>一道 golang 切片面试题 为什么 sl[:5] 会返回底层数组的数据呢？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import &amp;#34;fmt&amp;#34; func main() { sl := make([]int, 0, 10) appendFn := func(s []int) { // 值传递， s 并不是 sl。 // 但数组是引用类型， 所以可以修改底层数组 fmt.Println(&amp;#34;s ptr(old):&amp;#34;, s) // [] s = append(s, 10, 20, 30) fmt.Println(&amp;#34;s ptr(new):&amp;#34;, s) // [10,20,30] } fmt.Println(sl) // [] appendFn(sl) fmt.Println(sl) // [] // 这里有点坑， 并不是取的 sl ，而是底</description></item><item><title>golang 下划线完成对象的接口类型检查</title><link>https://tangx.in/posts/2021/08/26/golang-varible-decleare-with-blank-identifier/</link><pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/08/26/golang-varible-decleare-with-blank-identifier/</guid><description>golang 下划线完成对象的接口类型检查 在 Gin 源码中 有一行代码如下 1 var _ IRouter = &amp;amp;RouterGroup{} 乍一看， 是一个 赋值 操作， 但是前面又使用了 空白描述符(下划线) 。 这是什么意思呢？ 答案是： 接口类型检查 在 《Effective GO》 Interface Check 中的描述有相关描述。 全文如下。 One place this situation arises is when it is necessary to guarantee within the package implementing the type that it actually satisfies the interface. If a type-for</description></item><item><title>golang 中的时间处理</title><link>https://tangx.in/posts/2021/08/23/golang-time-operation/</link><pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/08/23/golang-time-operation/</guid><description>golang 中的时间处理 在 golang 中有一个很重要的 格式化时间的字符串 2006-01-02T15:04:05Z07:00 ， 这个也是 golang 默认时间模版模版中的 time.RFC3339 1 RFC3339 = &amp;#34;2006-01-02T15:04:05Z07:00&amp;#34; golang 中关于时间的处理， 用到了上面的 每一个 数字和字母。 需要特别注意的是， 时区用的是 7 而非 6 ， 因为 6 已经在 年（2006） 中出现了 创建时间对象 time.Time 1 2 3 4 5 6 7 8 9 10 // 1. 创建当前时间对象 now := time.Now() //</description></item><item><title>ginbinder 的书写过程-一起来看gin源码吧</title><link>https://tangx.in/posts/2021/08/20/ginbinder-how-to-develop/</link><pubDate>Fri, 20 Aug 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/08/20/ginbinder-how-to-develop/</guid><description>ginbind 的实现过程-一起来看gin源码吧 是的，没错。 如果你用过 gin 那么你一定知道，gin 中绑定参数的方式很零散。 c *gon.Context 给你提供了很多中方法， 例如BindHeader, BindURI 等等， 但是如果想要绑定 reqeust 中不同地方的参数， 那对不起咯，并没有。 另外， gin 中的 Bind 接口， 默认是包含了 参数验证 validate 功能的， 因此如果你</description></item><item><title>ginbinder 一次绑定所有 request 参数</title><link>https://tangx.in/posts/2021/08/19/ginbinder/</link><pubDate>Thu, 19 Aug 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/08/19/ginbinder/</guid><description>ginbinder 一次绑定 Request 中所有需要的数据 Usage 废弃/不可用: 弃用原生 tag form tag。 保持: 使用 tag uri 绑定路径中的参数。 作用于某个字段 就是 example.com/:some/:path 中 冒号后面的 保持: 使用 tag header 绑定 header。 作用于某个字段 新增: 新增 tag query tag 绑定通过 Query 传递的参数。 作用于某个字段 就是 example.com/some/path?a=1&amp;amp;b=2 中 问号后面的那一串 新增: 新增 tag cookie 绑定 cookie 中 简单 的键</description></item><item><title>go1.17泛型尝鲜</title><link>https://tangx.in/posts/2021/08/18/go117-generic-preview/</link><pubDate>Wed, 18 Aug 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/08/18/go117-generic-preview/</guid><description>go1.17 泛型尝鲜 语法格式如下， 需要使用 [T Ttype] 指定约束条件， 例如 [T any] 不做任何约束, [T MyInterface] 满足 MyInterface 的约束 接下来我们将尝试上述提到的内容。 1 2 3 func fname[T Ttype](args []T) T { // statement } 需要注意的是， 现在泛型在 go1.17 中依旧不是正式支持， 所以在 IDE 或者编辑器上会有报错。 编译需要指定额外的 -gcflags=-G=3 参数 1 go run -gcflags=-G=3 main.go 开始吧 不约束 any 首先，我们来</description></item><item><title>golang gin 使用 context 实现 ioc</title><link>https://tangx.in/posts/2021/07/28/ioc-by-gin-context/</link><pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/07/28/ioc-by-gin-context/</guid><description>golang gin 使用 context 实现 ioc gin 是一个流行的 golang webserver 的框架。 https://github.com/gin-gonic/gin gin 中 HandlerFunc (type HandlerFunc func(*Context)) 的使用随处可见, ex. Middleware , Handler 中。 1 2 3 4 router.GET(&amp;#34;/user/:name&amp;#34;, func(c *gin.Context) { name := c.Param(&amp;#34;name&amp;#34;) c.String(http.StatusOK, &amp;#34;Hello %s&amp;#34;, name) }) 因此，根据之前 golang context 实现 IoC 容器经验， 使用 *gin.Context 作为 IoC 容器再好不过了。 标准库 context.Context 是一个接口(interface)， gin.Context 是 gin 工程自己封装的的一个 struct， 并实现了该接口。 虽然</description></item><item><title>golang 使用 Context 实现 IoC 容器</title><link>https://tangx.in/posts/2021/07/27/ioc-by-golang-context/</link><pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/07/27/ioc-by-golang-context/</guid><description>golang 使用 Context 实现 IoC 容器 参考文章 控制反转（IoC）与依赖注入（DI） 指出了依赖注入可以降低程序的耦合性。 能更好的拆分功能与基础设施。 那么在 golang 中又怎么实现呢？ 代码地址 golang-context-ioc.go 实现了一个 MysqlDriver 实现我们所有的数据存取操作。 并在全局域中实例化了一个对象 my。 在 main.go 中创建了一个 ctx := context.Background() 使用使用 ctx 作为 IoC 容器， 使</description></item><item><title>Golang Block 到底是什么？ 怎么就能解决闭包变量冲突了？</title><link>https://tangx.in/posts/2021/06/22/golang-block/</link><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/06/22/golang-block/</guid><description>Golang Block 到底是什么？ 怎么就能解决闭包变量冲突了？ 什么？ 你告诉我 i:=i 不仅合法，而且还常用。甚至能解决并发编程中的变量冲突？ 以下这段代码出自 golang 官方 的 Effective GO 并发编程章节。 为了解决 goroute 中变量 req 冲突， 使用了语句 req := req https://golang.org/doc/effective_go#concurrency 1 2 3 4 5 6 7 8 9 10 func Serve(queue chan *Request) { for req := range queue { req := req // Create new instance of req for the goroutine. sem &amp;lt;- 1 go func() { process(req) &amp;lt;-sem</description></item><item><title>Golang知识点(defer): 面试经常变量在 defer 中的值， 其实在问变量的作用域</title><link>https://tangx.in/posts/2021/06/21/golang-defer-func-variables-scope/</link><pubDate>Mon, 21 Jun 2021 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2021/06/21/golang-defer-func-variables-scope/</guid><description>变量在 defer 中的值， 其实在问变量的作用域 有没有想过， 面试中经常问的 变量在 defer 之后的值， 其实是在问 函数变量的作用域 简单的说， defer 就是将当前操作放入 堆 中， 等待触发 return 的时候再拿出来执行。 符合堆的特色， 先进后出。 从细节来了， 还需要注意 变量 在 defer 中的 作用域 ？ 函数 的 执行操作 是在 入堆前还是后 ？ defer 中的函数</description></item><item><title>golang 为 struct 自动添加 tags</title><link>https://tangx.in/posts/2020/12/11/tips-auto-add-tags/</link><pubDate>Fri, 11 Dec 2020 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2020/12/11/tips-auto-add-tags/</guid><description>golang 为 struct 自动添加 tags vscode 中的 go 0.12.0 版本新加入了一个 auto add tags 的功能。 setting.json 配置如下 1 2 3 4 5 6 &amp;#34;go.addTags&amp;#34;: { &amp;#34;tags&amp;#34;: &amp;#34;yaml,json&amp;#34;, &amp;#34;options&amp;#34;: &amp;#34;yaml=omitempty,yaml=options2,yaml=options3,json=omitempty&amp;#34;, &amp;#34;promptForTags&amp;#34;: false, &amp;#34;transform&amp;#34;: &amp;#34;snakecase&amp;#34; }, 在 example.go 中创建一个 struct 1 2 3 4 5 type Person struct { Name string Age int Gender string } 将光标移动到 struct 结构体中， 使用 command + shift + p 选择 go: add tag for struct 即可 result 1 2 3 4 5 type Person struct { Name string `yaml:&amp;#34;name,omitempty,options2,options3&amp;#34; json:&amp;#34;name,omitempty&amp;#34;` Age int `yaml:&amp;#34;age,omitempty,options2,options3&amp;#34; json:&amp;#34;age,omitempty&amp;#34;` Gender string `yaml:&amp;#34;gender,omitempty,options2,options3&amp;#34; json:&amp;#34;gender,omitempty&amp;#34;` }</description></item><item><title>golang-use-regex-group</title><link>https://tangx.in/posts/2019/03/21/golang-use-regex-group/</link><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><guid>https://tangx.in/posts/2019/03/21/golang-use-regex-group/</guid><description>golang 使用 regex group 的值 与常用的语言正则不同， golang 使用 $1 表示 regex group。 而类似 sed, python 中常用的是 \1 golang playgroud 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;regexp&amp;#34; ) func main() { re := regexp.MustCompile(`([A-Z])`) s := re.ReplaceAllString(&amp;#34;UserCreate&amp;#34;, &amp;#34;.$1&amp;#34;) fmt.Println(s) // .User.Create } func Test_Regexp(t *testing.T) { chars := `(&amp;#39;|&amp;#34;)` str := `&amp;#34;123&amp;#39;abc&amp;#39;456&amp;#34;` re := regexp.MustCompile(chars) s := re.ReplaceAllString(str, `\$1`) // 这里可以使用 ` 反引号 fmt.Println(s) // \&amp;#34;123\&amp;#39;abc\&amp;#39;456\&amp;#34; } // https://stackoverflow.com/questions/43586091/how-golang-replace-string-by-regex-group python 1 2 3 import re name = re.sub(r&amp;#39;([A-Z])&amp;#39;, r&amp;#39;.\1&amp;#39;, &amp;#34;UserCreate&amp;#34;) print(name) # .User.Create</description></item></channel></rss>
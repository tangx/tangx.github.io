<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gin on 老麦的书房</title><link>https://typonotes.com/tags/gin/</link><description>Recent content in gin on 老麦的书房</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 14 Aug 2023 16:44:54 +0800</lastBuildDate><atom:link href="https://typonotes.com/tags/gin/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 集成 OpenTelemetry 笔记 - Gin Demo</title><link>https://typonotes.com/posts/2023/08/14/golang-opentelemetry-notes/</link><pubDate>Mon, 14 Aug 2023 16:44:54 +0800</pubDate><guid>https://typonotes.com/posts/2023/08/14/golang-opentelemetry-notes/</guid><description>Go 集成 OpenTelemetry 笔记 - Gin Demo 建议点击 查看原文 查看最新内容。 原文链接: https://typonotes.com/posts/2023/08/14/golang-opentelemetry-notes/ 为了更方便的查看代码， 建议直接跳转到 Github 仓库： https://github.com/tangx/opentelemetry-gin-demo 使用笔记 1. 使用 Otel-Collect-Contrib 初始化 trace.Provider 这里使用 app -&amp;gt; collector-contrib 进行转发， 应用不直接对后端的存储。 适配性 更高。 collector-contrib 最常见的两种协议 grpc / http(s)。 传入 endpoint 地址进行初始化 Provider， 参考代码 grpcExporter 和 httpExporter</description></item><item><title>开发 k8s 管理平台 - k8sailor 04. 使用 gin 创建第一个 API 接口</title><link>https://typonotes.com/posts/books/k8sailor/chapter01/04-init-httpserver/</link><pubDate>Tue, 10 Jan 2023 10:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/k8sailor/chapter01/04-init-httpserver/</guid><description>开发 k8s 管理平台 - k8sailor 04. 使用 gin 创建第一个 API 接口 原文地址: https://tangx.in/posts/books/k8sailor/chapter01/04-init-httpserver/ tag: https://github.com/tangx/k8sailor/tree/feat/04-httpserver-initial 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 cd cmd/k8sailor &amp;amp;&amp;amp; go run . httpserver 启动 web 服务器 Usage: k8sailor httpserver [flags] Flags: -h, --help help for httpserver Global Flags: --config string k8s 配置授权文件 (default &amp;#34;./k8sconfig/config.yml&amp;#34;) 2021/09/24 07:56:51 open config/local.yml: no such file or directory [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached. [GIN-debug] [WARNING] Running in &amp;#34;debug&amp;#34; mode. Switch to &amp;#34;release&amp;#34; mode in production. - using env: export GIN_MODE=release - using code: gin.SetMode(gin.ReleaseMode) [GIN-debug] GET /k8sailor/v0/ping --&amp;gt; github.com/tangx/k8sailor/cmd/k8sailor/apis.RootGroup.func1 (3 handlers) [GIN-debug] Listening</description></item><item><title>开发 k8s 管理平台 - k8sailor 05. RESTFul API 接口规范与请求应答约定</title><link>https://typonotes.com/posts/books/k8sailor/chapter01/05-design-restful-api-and-response-data/</link><pubDate>Tue, 10 Jan 2023 10:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/k8sailor/chapter01/05-design-restful-api-and-response-data/</guid><description>开发 k8s 管理平台 - k8sailor 05. RESTFul API 接口规范与请求应答约定 原文地址: https://tangx.in/posts/books/k8sailor/chapter01/05-design-restful-api-and-response-data/ tag: https://github.com/tangx/k8sailor/tree/feat/05-design-restful-api-and-response-data 强烈建议使用 RESTful 风格来设计 API 文档。 RESTful api 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # kubectl create deployment nginx-tools --image nginx:alpine --output=yaml --dry-run=client apiVersion: apps/v1 kind: Deployment metadata: creationTimestamp: null labels: app: nginx-tools name: nginx-tools # ... 省略 # kubectl create namespace hello --dry-run=client -o yaml apiVersion: v1 kind: Namespace metadata: creationTimestamp: null name: hello # ... 省略 可以看到， k8s api 中都有一个对应的 kind 描述资源类型， 这个正好符</description></item><item><title>开发 k8s 管理平台 - k8sailor 06. 使用 api/biz/dao 分层结构管理数据请求，获取 deployment 数据</title><link>https://typonotes.com/posts/books/k8sailor/chapter02/06-get-all-deployments/</link><pubDate>Tue, 10 Jan 2023 10:28:03 +0800</pubDate><guid>https://typonotes.com/posts/books/k8sailor/chapter02/06-get-all-deployments/</guid><description>开发 k8s 管理平台 - k8sailor 06. 使用 api/biz/dao 分层结构管理数据请求，获取 deployment 数据 原文地址: https://tangx.in/posts/books/k8sailor/chapter02/06-get-all-deployments/ tag: https://github.com/tangx/k8sailor/tree/feat/06-get-all-deployments client -&amp;gt; apis -&amp;gt; biz -&amp;gt; dao -&amp;gt; 将业务逻辑部分分为经典三层，想法是这样的，可能实现有错误。 apis 接入层: 只用于管理 http 请求与交互。 biz 业务层: 用于处理 api 层来的请求， 封装原始数据 dao 数据访问层: 与数据库, cluster 等交互。 存取数据。 重新调整目</description></item><item><title>gin 实现首页不缓存</title><link>https://typonotes.com/posts/2021/11/26/index-no-cache-in-gin/</link><pubDate>Fri, 26 Nov 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/11/26/index-no-cache-in-gin/</guid><description>在 gin 中实现首页不缓存 之前提到了在 nginx 中添加响应头 Cache-Control: no-cache 不缓存首页， 以便每次发布 CDN 都能回源到最新的资源。 nginx 的配置可能都是实施人员的操作， 或许不在掌控范围内。 自己控制起来很简单， 无非就是加一个 Header 头嘛。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/gin-gonic/gin&amp;#34; ) func main() { r := gin.Default() // 一</description></item><item><title>gin 内部重定向时 middleware 不可用异常</title><link>https://typonotes.com/posts/2021/09/27/gin-301-redirect-slash-cause-cors-error/</link><pubDate>Mon, 27 Sep 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/09/27/gin-301-redirect-slash-cause-cors-error/</guid><description>gin 内部重定向时 middleware 不可用异常 axios 请求时出现 cors error 在使用 axios 请求后端时，遇到 cors 跨域问题， 虽然已经在 gin 中添加了 cors 的 middleware 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func cors() gin.HandlerFunc { return func(c *gin.Context) { method := c.Request.Method origin := &amp;#34;*&amp;#34; if method != &amp;#34;&amp;#34; { c.Header(&amp;#34;Access-Control-Allow-Origin&amp;#34;, origin) // 可将将 * 替换为指定的域名 c.Header(&amp;#34;Access-Control-Allow-Methods&amp;#34;, &amp;#34;POST, GET, OPTIONS, PUT, DELETE, UPDATE&amp;#34;) c.Header(&amp;#34;Access-Control-Allow-Headers&amp;#34;, &amp;#34;Origin, X-Requested-With, Content-Type, Accept, Authorization,X-Token&amp;#34;) c.Header(&amp;#34;Access-Control-Expose-Headers&amp;#34;, &amp;#34;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Cache-Control, Content-Language, Content-Type&amp;#34;) c.Header(&amp;#34;Access-Control-Allow-Credentials&amp;#34;, &amp;#34;true&amp;#34;) } if method == &amp;#34;OPTIONS&amp;#34; { c.AbortWithStatus(http.StatusNoContent) } } } 问题原因 gin Middleware</description></item><item><title>ginbinder 一次绑定所有 request 参数</title><link>https://typonotes.com/posts/2021/08/19/ginbinder/</link><pubDate>Thu, 19 Aug 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/08/19/ginbinder/</guid><description>ginbinder 一次绑定 Request 中所有需要的数据 Usage 废弃/不可用: 弃用原生 tag form tag。 保持: 使用 tag uri 绑定路径中的参数。 作用于某个字段 就是 example.com/:some/:path 中 冒号后面的 保持: 使用 tag header 绑定 header。 作用于某个字段 新增: 新增 tag query tag 绑定通过 Query 传递的参数。 作用于某个字段 就是 example.com/some/path?a=1&amp;amp;b=2 中 问号后面的那一串 新增: 新增 tag cookie 绑定 cookie 中 简单 的键</description></item><item><title>golang gin 使用 context 实现 ioc</title><link>https://typonotes.com/posts/2021/07/28/ioc-by-gin-context/</link><pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate><guid>https://typonotes.com/posts/2021/07/28/ioc-by-gin-context/</guid><description>golang gin 使用 context 实现 ioc gin 是一个流行的 golang webserver 的框架。 https://github.com/gin-gonic/gin gin 中 HandlerFunc (type HandlerFunc func(*Context)) 的使用随处可见, ex. Middleware , Handler 中。 1 2 3 4 router.GET(&amp;#34;/user/:name&amp;#34;, func(c *gin.Context) { name := c.Param(&amp;#34;name&amp;#34;) c.String(http.StatusOK, &amp;#34;Hello %s&amp;#34;, name) }) 因此，根据之前 golang context 实现 IoC 容器经验， 使用 *gin.Context 作为 IoC 容器再好不过了。 标准库 context.Context 是一个接口(interface)， gin.Context 是 gin 工程自己封装的的一个 struct， 并实现了该接口。 虽然</description></item></channel></rss>